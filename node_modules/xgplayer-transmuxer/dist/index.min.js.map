{"version":3,"file":"index.min.js","sources":["../src/model/types.js","../src/model/video-track.js","../src/model/audio-track.js","../src/model/video-sample.js","../src/model/audio-sample.js","../src/model/metadata-track.js","../src/utils/exp-golomb.js","../src/utils/logger.js","../src/utils/utf8.js","../src/utils/env.js","../src/utils/index.js","../src/codec/nalu.js","../src/codec/avc.js","../src/codec/aac.js","../src/codec/hevc.js","../src/flv/fixer.js","../src/flv/amf.js","../src/flv/index.js","../src/mpeg-ts/fixer.js","../src/mpeg-ts/index.js","../src/mp4/mp4-parser.js","../src/mp4/fmp4-demuxer.js","../src/mp4/buffer.js","../src/mp4/mp4.js","../src/mp4/logger.js","../../../node_modules/crypto-es/lib/md5.js","../src/mp4/fmp4-remuxer.js","../../../node_modules/crypto-es/lib/core.js","../../../node_modules/crypto-es/lib/enc-base64.js","../../../node_modules/crypto-es/lib/evpkdf.js","../../../node_modules/crypto-es/lib/cipher-core.js","../../../node_modules/crypto-es/lib/aes.js","../../../node_modules/crypto-es/lib/mode-ctr.js","../../../node_modules/crypto-es/lib/pad-nopadding.js","../src/mp4/crypto/crypto.js","../src/mp4/mp4-demuxer.js","../src/mp4/mp4-remuxer.js","../src/index.umd.js"],"sourcesContent":["/** @enum {string} */\nexport const TrackType = {\n  VIDEO: 'video',\n  AUDIO: 'audio',\n  METADATA: 'metadata'\n}\n\n/** @enum {string} */\nexport const VideoCodecType = {\n  AVC: 'avc',\n  HEVC: 'hevc'\n}\n\n/** @enum {string} */\nexport const AudioCodecType = {\n  AAC: 'aac',\n  G711PCMA: 'g7110a',\n  G711PCMU: 'g7110m'\n}\n\n/** @enum {string} */\nexport const WarningType = {\n  LARGE_AV_SHIFT: 'LARGE_AV_SHIFT',\n  LARGE_VIDEO_GAP: 'LARGE_VIDEO_GAP',\n  LARGE_VIDEO_GAP_BETWEEN_CHUNK: 'LARGE_VIDEO_GAP_BETWEEN_CHUNK',\n  LARGE_AUDIO_GAP: 'LARGE_AUDIO_GAP',\n  AUDIO_FILLED: 'AUDIO_FILLED',\n  AUDIO_DROPPED: 'AUDIO_DROPPED'\n}\n","import { TrackType, VideoCodecType } from './types'\n\nexport class VideoTrack {\n  id = 1\n\n  /** @readonly */\n  type = TrackType.VIDEO\n\n  codecType = VideoCodecType.AVC\n\n  pid = -1 // ts use\n\n  /** @type {Uint8Array | Object} */\n  hvcC = undefined\n\n  codec = ''\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  sequenceNumber = 0\n\n  baseMediaDecodeTime = 0\n\n  baseDts = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./video-sample').VideoSample[]} */\n  samples = []\n\n  /** @type {Uint8Array[]} */\n  pps = []\n\n  /** @type {Uint8Array[]} */\n  sps = []\n\n  /** @type {Uint8Array[]} */\n  vps = []\n\n  fpsNum = 0\n\n  fpsDen = 0\n\n  /** @type {[number, number]} */\n  sarRatio = [] // [hSpacing, vSpacing]\n\n  width = 0\n\n  height = 0\n\n  nalUnitSize = 4\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  isVideo = true\n\n  kid = null\n\n  pssh = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber =\n    this.width =\n    this.height =\n    this.fpsDen =\n    this.fpsNum =\n    this.duration =\n    this.baseMediaDecodeTime =\n    this.timescale = 0\n    this.codec = ''\n    this.present = false\n    this.pid = -1\n    this.pps = []\n    this.sps = []\n    this.vps = []\n    this.sarRatio = []\n    this.samples = []\n    this.warnings = []\n    this.hvcC = null\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(this.pps.length && this.sps.length && this.codec)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption (){\n    return this.isVideoEncryption\n  }\n}\n","import { TrackType, AudioCodecType } from './types'\n\nexport class AudioTrack {\n  id = 2\n\n  /** @readonly */\n  type = TrackType.AUDIO\n\n  codecType = AudioCodecType.AAC\n\n  pid = -1\n\n  codec = ''\n\n  sequenceNumber = 0\n\n  sampleDuration = 0\n\n  timescale = 0\n\n  formatTimescale = 0\n\n  baseMediaDecodeTime = 0\n\n  duration = 0\n\n  warnings = []\n\n  /** @type {import('./audio-sample').AudioSample[]} */\n  samples = []\n\n  baseDts = 0\n\n  sampleSize = 16\n\n  sampleRate = 0\n\n  channelCount = 0\n\n  objectType = 0\n\n  sampleRateIndex = 0\n\n  /** @type {number[]} */\n  config = []\n\n  present = false\n\n  isVideoEncryption = false\n\n  isAudioEncryption = false\n\n  kid = null\n\n  /** @type {any} */\n  ext\n\n  reset () {\n    this.sequenceNumber = 0\n    this.timescale = 0\n    this.sampleDuration = 0\n    this.sampleRate = 0\n    this.channelCount = 0\n    this.baseMediaDecodeTime = 0\n    this.present = false\n    this.pid = -1\n    this.codec = ''\n    this.samples = []\n    this.config = []\n    this.warnings = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!(this.sampleRate && this.channelCount && this.codec && this.codecType === AudioCodecType.AAC)\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!this.samples.length\n  }\n\n  get isEncryption (){\n    return this.isAudioEncryption\n  }\n}\n","/**\n * @typedef {Object} VideoFlag\n * @property {number} [isLeading=0]\n * @property {number} [dependsOn=1]\n * @property {number} [isDependedOn=0]\n * @property {number} [hasRedundancy=0]\n * @property {number} [paddingValue=0]\n * @property {number} [degradationPriority=0]\n * @property {number} [isNonSyncSample=1]\n */\n\nexport class VideoSample {\n  /** @type {VideoFlag} */\n  flag = {}\n\n  keyframe = false\n\n  gopId = 0\n\n  duration = 0\n\n  size = 0\n\n  units = []\n\n  chromaFormat = 420\n\n  // sampleOffset = 0\n\n  /**\n   * @param {number} pts\n   * @param {number} dts\n   * @param {Uint8Array[]} [units]\n   */\n  constructor (pts, dts, units) {\n    this.originPts = this.pts = pts\n    this.originDts = this.dts = dts\n    if (units) this.units = units\n  }\n\n  /**\n   * @returns {number}\n   */\n  get cts () {\n    return this.pts - this.dts\n  }\n\n  setToKeyframe () {\n    this.keyframe = true\n    this.flag.dependsOn = 2\n    this.flag.isNonSyncSample = 0\n  }\n}\n","export class AudioSample {\n  duration = 1024\n\n  flag = { dependsOn: 2, isNonSyncSample: 0 }\n  keyframe = true\n\n  /**\n   * @param {number} pts\n   * @param {Uint8Array} data\n   * @param {number} [duration=1024]\n   */\n  constructor (pts, data, duration, sampleOffset) {\n    this.originPts = this.pts = this.dts = pts\n    this.data = data\n    this.size = data.byteLength\n    this.sampleOffset = sampleOffset\n    if (duration) this.duration = duration\n  }\n}\n","import { TrackType } from './types'\n\nclass Sample {\n  time = 0 // second\n\n  /**\n   * @param {Object} data\n   * @param {number} pts\n   */\n  constructor (data, pts) {\n    this.data = data\n    this.originPts = this.pts = pts\n  }\n}\n\nexport class FlvScriptSample extends Sample {}\n\nexport class SeiSample extends Sample {}\n\nexport class MetadataTrack {\n  /** @readonly */\n  id = 3\n\n  /** @readonly */\n  type = TrackType.METADATA\n\n  timescale = 0\n\n  /** @type {FlvScriptSample[]} */\n  flvScriptSamples = []\n\n  /** @type {SeiSample[]} */\n  seiSamples = []\n\n  /**\n   * @returns {boolean}\n   */\n  exist () {\n    return !!((this.flvScriptSamples.length || this.seiSamples.length) && this.timescale)\n  }\n\n  reset () {\n    this.timescale = 0\n    this.flvScriptSamples = []\n    this.seiSamples = []\n  }\n\n  /**\n   * @returns {boolean}\n   */\n  hasSample () {\n    return !!(this.flvScriptSamples.length || this.seiSamples.length)\n  }\n}\n","export class ExpGolomb {\n  _bytesAvailable\n\n  _bitsAvailable = 0\n\n  _word = 0\n\n  constructor (data) {\n    if (!data) throw new Error('ExpGolomb data params is required')\n    this._data = data\n    this._bytesAvailable = data.byteLength\n    if (this._bytesAvailable) this._loadWord()\n  }\n\n  get bitsAvailable () {\n    return this._bitsAvailable\n  }\n\n  _loadWord () {\n    const position = this._data.byteLength - this._bytesAvailable\n    const availableBytes = Math.min(4, this._bytesAvailable)\n    if (availableBytes === 0) throw new Error('No bytes available')\n\n    const workingBytes = new Uint8Array(4)\n    workingBytes.set(this._data.subarray(position, position + availableBytes))\n\n    this._word = new DataView(workingBytes.buffer).getUint32(0)\n    this._bitsAvailable = availableBytes * 8\n    this._bytesAvailable -= availableBytes\n  }\n\n  skipBits (count) {\n    if (this._bitsAvailable > count) {\n      this._word <<= count\n      this._bitsAvailable -= count\n    } else {\n      count -= this._bitsAvailable\n      const skipBytes = Math.floor(count / 8)\n      count -= (skipBytes * 8)\n      this._bytesAvailable -= skipBytes\n      this._loadWord()\n      this._word <<= count\n      this._bitsAvailable -= count\n    }\n  }\n\n  readBits (size) {\n    if (size > 32) {\n      throw new Error('Cannot read more than 32 bits')\n    }\n\n    let bits = Math.min(this._bitsAvailable, size)\n    const val = this._word >>> (32 - bits)\n\n    this._bitsAvailable -= bits\n    if (this._bitsAvailable > 0) {\n      this._word <<= bits\n    } else if (this._bytesAvailable > 0) {\n      this._loadWord()\n    }\n\n    bits = size - bits\n    if (bits > 0 && this._bitsAvailable) {\n      return (val << bits) | this.readBits(bits)\n    }\n    return val\n  }\n\n  skipLZ () {\n    let leadingZeroCount\n    for (\n      leadingZeroCount = 0;\n      leadingZeroCount < this._bitsAvailable;\n      ++leadingZeroCount\n    ) {\n      if ((this._word & (0x80000000 >>> leadingZeroCount)) !== 0) {\n        this._word <<= leadingZeroCount\n        this._bitsAvailable -= leadingZeroCount\n        return leadingZeroCount\n      }\n    }\n    this._loadWord()\n    return leadingZeroCount + this.skipLZ()\n  }\n\n  skipUEG () {\n    this.skipBits(1 + this.skipLZ())\n  }\n\n  readUEG () {\n    const clz = this.skipLZ()\n    return this.readBits(clz + 1) - 1\n  }\n\n  readEG () {\n    const val = this.readUEG()\n    if (1 & val) {\n      return (1 + val) >>> 1\n    }\n    return -1 * (val >>> 1)\n  }\n\n  readBool () {\n    return this.readBits(1) === 1\n  }\n\n  readUByte () {\n    return this.readBits(8)\n  }\n\n  skipScalingList (count) {\n    let lastScale = 8\n    let nextScale = 8\n    let deltaScale\n    for (let j = 0; j < count; j++) {\n      if (nextScale !== 0) {\n        deltaScale = this.readEG()\n        nextScale = (lastScale + deltaScale + 256) % 256\n      }\n      lastScale = nextScale === 0 ? lastScale : nextScale\n    }\n  }\n}\n","export class Logger {\n  constructor (name) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","export class UTF8 {\n  /**\n   *\n   * @param {Uint8Array} uint8array\n   * @return {string}\n   */\n  static decode (uint8array) {\n    const out = []\n    const input = uint8array\n    let i = 0\n    const length = uint8array.length\n\n    while (i < length) {\n      if (input[i] < 0x80) {\n        out.push(String.fromCharCode(input[i]))\n        ++i\n        continue\n      } else if (input[i] < 0xC0) {\n        // fallthrough\n      } else if (input[i] < 0xE0) {\n        if (UTF8._checkContinuation(input, i, 1)) {\n          const ucs4 = (input[i] & 0x1F) << 6 | (input[i + 1] & 0x3F)\n          if (ucs4 >= 0x80) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 2\n            continue\n          }\n        }\n      } else if (input[i] < 0xF0) {\n        if (UTF8._checkContinuation(input, i, 2)) {\n          const ucs4 = (input[i] & 0xF) << 12 | (input[i + 1] & 0x3F) << 6 | input[i + 2] & 0x3F\n          if (ucs4 >= 0x800 && (ucs4 & 0xF800) !== 0xD800) {\n            out.push(String.fromCharCode(ucs4 & 0xFFFF))\n            i += 3\n            continue\n          }\n        }\n      } else if (input[i] < 0xF8) {\n        if (UTF8._checkContinuation(input, i, 3)) {\n          let ucs4 = (input[i] & 0x7) << 18 | (input[i + 1] & 0x3F) << 12 |\n                    (input[i + 2] & 0x3F) << 6 | (input[i + 3] & 0x3F)\n          if (ucs4 > 0x10000 && ucs4 < 0x110000) {\n            ucs4 -= 0x10000\n            out.push(String.fromCharCode((ucs4 >>> 10) | 0xD800))\n            out.push(String.fromCharCode((ucs4 & 0x3FF) | 0xDC00))\n            i += 4\n            continue\n          }\n        }\n      }\n      out.push(String.fromCharCode(0xFFFD))\n      ++i\n    }\n\n    return out.join('')\n  }\n\n  static _checkContinuation (uint8array, start, checkLength) {\n    const array = uint8array\n    if (start + checkLength < array.length) {\n      while (checkLength--) {\n        if ((array[++start] & 0xC0) !== 0x80) {\n          return false\n        }\n      }\n      return true\n    } else {\n      return false\n    }\n  }\n}\n","export const isBrowser = typeof window !== 'undefined'\n\nconst ua = isBrowser && navigator.userAgent.toLocaleLowerCase()\n\n// eslint-disable-next-line no-lookahead-lookbehind-regexp/no-lookahead-lookbehind-regexp\nexport const isSafari = isBrowser && /^((?!chrome|android).)*safari/.test(ua)\nexport const isFirefox = isBrowser && ua.includes('firefox')\nexport const isAndroid = isBrowser && ua.includes('android')\n","/* c8 ignore next 4 */\nexport { ExpGolomb } from './exp-golomb'\nexport { Logger } from './logger'\nexport { UTF8 } from './utf8'\nexport * from './env'\n\nexport function concatUint8Array (...arr) {\n  arr = arr.filter(Boolean)\n  const data = new Uint8Array(arr.reduce((p, c) => p + c.byteLength, 0))\n  let prevLen = 0\n  arr.forEach((d) => {\n    data.set(d, prevLen)\n    prevLen += d.byteLength\n  })\n  return data\n}\n\nexport const MAX_SIZE = Math.pow(2, 32)\n\nexport function readBig16 (data, i = 0) {\n  return (data[i] << 8) + (data[i + 1] || 0)\n}\n\nexport function readBig24 (data, i = 0) {\n  return (data[i] << 16) + (data[i + 1] << 8) + (data[i + 2] || 0)\n}\n\nexport function readBig32 (data, i = 0) {\n  return (data[i] << 24 >>> 0) + (data[i + 1] << 16) + (data[i + 2] << 8) + (data[i + 3] || 0)\n}\n\nexport function readBig64 (data, i = 0) {\n  return readBig32(data, i) * MAX_SIZE + readBig32(data, i + 4)\n}\n\nexport function getAvcCodec (codecs) {\n  let codec = 'avc1.'\n  let h\n  for (let i = 0; i < 3; i++) {\n    h = codecs[i].toString(16)\n    if (h.length < 2) h = `0${h}`\n    codec += h\n  }\n  return codec\n}\n\nexport function formatIV (arr) {\n  let iv = ''\n  arr.forEach(value => {\n    iv += bufferToString(value)\n  })\n  if (iv.length <= 32) {\n    const len = 32 - iv.length\n    for (let i = 0; i < len; i++) {\n      iv += '0'\n    }\n  }\n  return iv\n}\n\nexport function parse (a) {\n  if (!Array.isArray(a)) {\n    const arr = []\n    let value = ''\n    for (let i = 0; i < a.length; i++) {\n      if (i % 2) {\n        value = a[i - 1] + a[i]\n        arr.push(parseInt(value, 16))\n        value = ''\n      }\n    }\n    return arr\n  }\n  return a.map(item => { return parseInt(item, 16) })\n}\nfunction bufferToString (value) {\n  return ('0' + (Number(value).toString(16))).slice(-2).toUpperCase()\n}\n\nexport function hashVal (str) {\n  let hash = 0; let i; let chr\n  if (str.length === 0) return hash\n  for (i = 0; i < str.length; i++) {\n    chr = str.charCodeAt(i)\n    hash = ((hash << 5) - hash) + chr\n    hash |= 0\n  }\n  return hash\n}\n","import { readBig32 } from '../utils'\n\nexport class NALu {\n  static parseAnnexB (data) {\n    const len = data.length\n    let start = 2\n    let end = 0\n    while (data[start] !== null && data[start] !== undefined && data[start] !== 1) {\n      start++\n    }\n    start++\n    end = start + 2\n\n    if (end >= len) return []\n\n    const units = []\n\n    while (end < len) {\n      switch (data[end]) {\n        case 0:\n          if (data[end - 1] !== 0) {\n            end += 2\n            break\n          } else if (data[end - 2] !== 0) {\n            end++\n            break\n          }\n\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n\n          do {\n            end++\n          } while (data[end] !== 1 && end < len)\n          start = end + 1\n          end = start + 2\n          break\n        case 1:\n          if (data[end - 1] !== 0 || data[end - 2] !== 0) {\n            end += 3\n            break\n          }\n          if (start !== end - 2) units.push(data.subarray(start, end - 2))\n          start = end + 1\n          end = start + 2\n          break\n        default:\n          end += 3\n          break\n      }\n    }\n\n    if (start < len) units.push(data.subarray(start))\n\n    return units\n  }\n\n  static parseAvcC (data, size = 4) {\n    if (data.length < 4) return\n    const dataLen = data.length\n    const units = []\n\n    let offset = 0\n    let length\n    while ((offset + size) < dataLen) {\n      length = readBig32(data, offset)\n      if (size === 3) length >>>= 8\n      offset += size\n\n      if (!length) continue\n      if (offset + length > dataLen) {\n        break\n      }\n\n      units.push(data.subarray(offset, offset + length))\n      offset += length\n    }\n\n    return units\n  }\n\n  static parseSEI (unit, isHevc) {\n    const len = unit.length\n    let i = isHevc ? 2 : 1\n    let type = 0\n    let size = 0\n    let uuid = ''\n\n    while (unit[i] === 255) {\n      type += 255\n      i++\n    }\n\n    type += unit[i++]\n\n    while (unit[i] === 255) {\n      size += 255\n      i++\n    }\n    size += unit[i++]\n\n    if (type === 5 && len > i + 16) {\n      for (let j = 0; j < 16; j++) {\n        uuid += unit[i].toString(16)\n        i++\n      }\n    }\n\n    return {\n      payload: unit.subarray(i, i + size), type, size, uuid\n    }\n  }\n\n  static removeEPB (uint) {\n    const length = uint.byteLength\n    const emulationPreventionBytesPositions = []\n    let i = 1\n\n    while (i < length - 2) {\n      if (uint[i] === 0 && uint[i + 1] === 0 && uint[i + 2] === 0x03) {\n        emulationPreventionBytesPositions.push(i + 2)\n        i += 2\n      } else {\n        i++\n      }\n    }\n\n    if (!emulationPreventionBytesPositions.length) return uint\n\n    const newLength = length - emulationPreventionBytesPositions.length\n    const newData = new Uint8Array(newLength)\n\n    let sourceIndex = 0\n    for (i = 0; i < newLength; sourceIndex++, i++) {\n      if (sourceIndex === emulationPreventionBytesPositions[0]) {\n        sourceIndex++\n        emulationPreventionBytesPositions.shift()\n      }\n      newData[i] = uint[sourceIndex]\n    }\n\n    return newData\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb, getAvcCodec } from '../utils'\n\nexport class AVC {\n  static parseAVCDecoderConfigurationRecord (data) {\n    if (data.length < 7) return\n    const nalUnitSize = (data[4] & 3) + 1\n\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n\n    let offset = 6\n    const spsCount = data[5] & 0x1f\n    let spsSize\n    for (let i = 0; i < spsCount; i++) {\n      spsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!spsSize) continue\n\n      const sps = data.subarray(offset, offset + spsSize)\n      offset += spsSize\n      spsArr.push(sps)\n\n      if (!spsParsed) {\n        spsParsed = AVC.parseSPS(NALu.removeEPB(sps))\n      }\n    }\n\n    const ppsCount = data[offset]\n    offset++\n    let ppsSize\n    for (let i = 0; i < ppsCount; i++) {\n      ppsSize = (data[offset] << 8) | data[offset + 1]\n      offset += 2\n      if (!ppsSize) continue\n      ppsArr.push(data.subarray(offset, offset + ppsSize))\n      offset += ppsSize\n    }\n\n    return {\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseSPS (unit) {\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n\n    const profileIdc = eg.readUByte()\n    const profileCompatibility = eg.readUByte()\n    const levelIdc = eg.readUByte()\n    eg.skipUEG()\n\n    let chromaFormat = 420\n    if (\n      profileIdc === 100 ||\n      profileIdc === 110 ||\n      profileIdc === 122 ||\n      profileIdc === 244 ||\n      profileIdc === 44 ||\n      profileIdc === 83 ||\n      profileIdc === 86 ||\n      profileIdc === 118 ||\n      profileIdc === 128 ||\n      profileIdc === 138 ||\n      profileIdc === 144\n    ) {\n      const chromaFormatIdc = eg.readUEG()\n      if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n      if (chromaFormatIdc === 3) eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      eg.skipBits(1)\n      if (eg.readBool()) {\n        const scalingListCount = chromaFormatIdc !== 3 ? 8 : 12\n        for (let i = 0; i < scalingListCount; i++) {\n          if (eg.readBool()) {\n            if (i < 6) {\n              eg.skipScalingList(16)\n            } else {\n              eg.skipScalingList(64)\n            }\n          }\n        }\n      }\n    }\n\n    eg.skipUEG()\n    const picOrderCntType = eg.readUEG()\n    if (picOrderCntType === 0) {\n      eg.readUEG()\n    } else if (picOrderCntType === 1) {\n      eg.skipBits(1)\n      eg.skipUEG()\n      eg.skipUEG()\n      const numRefFramesInPicOrderCntCycle = eg.readUEG()\n      for (let i = 0; i < numRefFramesInPicOrderCntCycle; i++) {\n        eg.skipUEG()\n      }\n    }\n\n    eg.skipUEG()\n    eg.skipBits(1)\n    const picWidthInMbsMinus1 = eg.readUEG()\n    const picHeightInMapUnitsMinus1 = eg.readUEG()\n    const frameMbsOnlyFlag = eg.readBits(1)\n    if (frameMbsOnlyFlag === 0) eg.skipBits(1)\n    eg.skipBits(1)\n\n    let frameCropLeftOffset = 0\n    let frameCropRightOffset = 0\n    let frameCropTopOffset = 0\n    let frameCropBottomOffset = 0\n\n    if (eg.readBool()) {\n      frameCropLeftOffset = eg.readUEG()\n      frameCropRightOffset = eg.readUEG()\n      frameCropTopOffset = eg.readUEG()\n      frameCropBottomOffset = eg.readUEG()\n    }\n\n    let sarRatio\n    let fixedFrame\n    let fpsNum\n    let fpsDen\n    let fps\n    if (eg.readBool()) {\n      if (eg.readBool()) {\n        const aspectRatioIdc = eg.readUByte()\n        switch (aspectRatioIdc) {\n          case 1: sarRatio = [1, 1]; break\n          case 2: sarRatio = [12, 11]; break\n          case 3: sarRatio = [10, 11]; break\n          case 4: sarRatio = [16, 11]; break\n          case 5: sarRatio = [40, 33]; break\n          case 6: sarRatio = [24, 11]; break\n          case 7: sarRatio = [20, 11]; break\n          case 8: sarRatio = [32, 11]; break\n          case 9: sarRatio = [80, 33]; break\n          case 10: sarRatio = [18, 11]; break\n          case 11: sarRatio = [15, 11]; break\n          case 12: sarRatio = [64, 33]; break\n          case 13: sarRatio = [160, 99]; break\n          case 14: sarRatio = [4, 3]; break\n          case 15: sarRatio = [3, 2]; break\n          case 16: sarRatio = [2, 1]; break\n          case 255: {\n            sarRatio = [\n              (eg.readUByte() << 8) | eg.readUByte(),\n              (eg.readUByte() << 8) | eg.readUByte()\n            ]\n            break\n          }\n          default:\n        }\n      }\n\n      if (eg.readBool()) eg.readBool()\n\n      if (eg.readBool()) {\n        eg.readBits(4)\n        if (eg.readBool()) eg.readBits(24)\n      }\n\n      if (eg.readBool()) {\n        eg.readUEG()\n        eg.readUEG()\n      }\n\n      if (eg.readBool()) {\n        const numUnitsInTick = eg.readBits(32)\n        const timeScale = eg.readBits(32)\n        fixedFrame = eg.readBool()\n\n        fpsNum = timeScale\n        fpsDen = numUnitsInTick * 2\n        fps = fpsNum / fpsDen\n      }\n    }\n\n    return {\n      codec: getAvcCodec(unit.subarray(1, 4)),\n      profileIdc,\n      profileCompatibility,\n      levelIdc,\n      chromaFormat,\n      width: Math.ceil(\n        (picWidthInMbsMinus1 + 1) * 16 -\n          2 * (frameCropLeftOffset + frameCropRightOffset)\n      ),\n      height:\n        (2 - frameMbsOnlyFlag) * (picHeightInMapUnitsMinus1 + 1) * 16 -\n        (frameMbsOnlyFlag ? 2 : 4) *\n          (frameCropTopOffset + frameCropBottomOffset),\n      sarRatio,\n      fpsNum,\n      fpsDen,\n      fps,\n      fixedFrame\n    }\n  }\n}\n","import { isFirefox, isAndroid } from '../utils'\n\nexport class AAC {\n  static FREQ = [\n    96000,\n    88200,\n    64000,\n    48000,\n    44100,\n    32000,\n    24000,\n    22050,\n    16000,\n    12000,\n    11025,\n    8000,\n    7350\n  ];\n\n  static getRateIndexByRate (rate) {\n    return AAC.FREQ.indexOf(rate)\n  }\n\n  static parseADTS (data, pts) {\n    const len = data.length\n    let i = 0\n\n    while ((i + 2) < len) {\n      if (data[i] === 0xff && (data[i + 1] & 0xf6) === 0xf0) {\n        break\n      }\n      i++\n    }\n\n    if (i >= len) return\n\n    const skip = i\n    const frames = []\n    const samplingFrequencyIndex = (data[i + 2] & 0x3c) >>> 2\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    if (!sampleRate) throw new Error(`Invalid sampling index: ${samplingFrequencyIndex}`)\n    const objectType = ((data[i + 2] & 0xc0) >>> 6) + 1\n    const channelCount = ((data[i + 2] & 1) << 2) | ((data[i + 3] & 0xc0) >>> 6)\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    let protectionSkipBytes\n    let frameLength\n    let frameIndex = 0\n    const duration = AAC.getFrameDuration(sampleRate)\n\n    while ((i + 7) < len) {\n      if ((data[i] !== 0xff) || (data[i + 1] & 0xF6) !== 0xf0) {\n        i++\n        continue\n      }\n\n      frameLength = ((data[i + 3] & 0x03) << 11) | (data[i + 4] << 3) | ((data[i + 5] & 0xe0) >> 5)\n      if ((len - i) < frameLength) break\n\n      protectionSkipBytes = (~data[i + 1] & 0x01) * 2\n      frames.push({\n        pts: pts + frameIndex * duration,\n        data: data.subarray(i + 7 + protectionSkipBytes, i + frameLength)\n      })\n\n      frameIndex++\n      i += frameLength\n    }\n\n    return {\n      skip,\n      remaining: i >= len ? undefined : data.subarray(i),\n      frames,\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      codec,\n      config,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static parseAudioSpecificConfig (data) {\n    if (!data.length) return\n    const objectType = data[0] >>> 3\n    const samplingFrequencyIndex = ((data[0] & 0x07) << 1) | (data[1] >>> 7)\n    const channelCount = (data[1] & 0x78) >>> 3\n    const sampleRate = AAC.FREQ[samplingFrequencyIndex]\n    // play as no audio track stream\n    if (!sampleRate) return\n    const { config, codec } = AAC._getConfig(samplingFrequencyIndex, channelCount, objectType)\n\n    return {\n      samplingFrequencyIndex,\n      sampleRate,\n      objectType,\n      channelCount,\n      config,\n      codec,\n      originCodec: `mp4a.40.${objectType}`\n    }\n  }\n\n  static getFrameDuration (rate, timescale = 90000) {\n    return 1024 * timescale / rate\n  }\n\n  static _getConfig (samplingIndex, channelCount, originObjectType) {\n    const config = []\n    let objectType\n    let extensionSamplingIndex\n    if (isFirefox) {\n      if (samplingIndex >= 6) { // use SBR (HE-AAC)\n        objectType = 5\n        extensionSamplingIndex = samplingIndex - 3\n      } else { // use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    } else if (isAndroid) { // use LC-AAC\n      objectType = 2\n      extensionSamplingIndex = samplingIndex\n    } else { // use HE-AAC\n      objectType = (originObjectType === 2 || originObjectType === 5) ? originObjectType : 5\n      extensionSamplingIndex = samplingIndex\n\n      if (samplingIndex >= 6) {\n        extensionSamplingIndex = samplingIndex - 3\n      } else if (channelCount === 1) { // Mono channel, use LC-AAC\n        objectType = 2\n        extensionSamplingIndex = samplingIndex\n      }\n    }\n\n    config[0] = objectType << 3\n    config[0] |= (samplingIndex & 0x0e) >> 1\n    config[1] = (samplingIndex & 0x01) << 7\n    config[1] |= channelCount << 3\n    if (objectType === 5) {\n      config[1] |= ((extensionSamplingIndex & 0x0e) >> 1)\n      config[2] = (extensionSamplingIndex & 0x01) << 7\n      config[2] |= (2 << 2)\n      config[3] = 0\n    }\n\n    return {\n      config,\n      codec: `mp4a.40.${objectType}`\n    }\n  }\n\n  /* c8 ignore next 65 */\n  static getSilentFrame (codec, channelCount) {\n    switch (codec) {\n      case 'mp4a.40.2':\n        if (channelCount === 1) {\n          return new Uint8Array([0x00, 0xc8, 0x00, 0x80, 0x23, 0x80])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x21, 0x00, 0x49, 0x90, 0x02, 0x19, 0x00, 0x23, 0x80\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x8e\n          ])\n        } if (channelCount === 4) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x80, 0x2c, 0x80, 0x08, 0x02, 0x38\n          ])\n        } if (channelCount === 5) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x38\n          ])\n        } if (channelCount === 6) {\n          return new Uint8Array([\n            0x00, 0xc8, 0x00, 0x80, 0x20, 0x84, 0x01, 0x26, 0x40, 0x08, 0x64,\n            0x00, 0x82, 0x30, 0x04, 0x99, 0x00, 0x21, 0x90, 0x02, 0x00, 0xb2,\n            0x00, 0x20, 0x08, 0xe0\n          ])\n        }\n        break\n      default:\n        if (channelCount === 1) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x4e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x1c, 0x6, 0xf1, 0xc1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 2) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        } if (channelCount === 3) {\n          return new Uint8Array([\n            0x1, 0x40, 0x22, 0x80, 0xa3, 0x5e, 0xe6, 0x80, 0xba, 0x8, 0x0, 0x0,\n            0x0, 0x0, 0x95, 0x0, 0x6, 0xf1, 0xa1, 0xa, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a, 0x5a,\n            0x5a, 0x5e\n          ])\n        }\n        break\n    }\n  }\n}\n","import { NALu } from './nalu'\nimport { ExpGolomb } from '../utils'\n\nexport class HEVC {\n  static parseHEVCDecoderConfigurationRecord (data, hvcC = {}) {\n    if (data.length < 23) return\n    hvcC = hvcC || {}\n    const nalUnitSize = (data[21] & 3) + 1\n\n    let vpsParsed\n    let spsParsed\n    const spsArr = []\n    const ppsArr = []\n    const vpsArr = []\n\n    let offset = 23\n    const numOfArrays = data[22]\n\n    let nalUnitType\n    let numNalus\n    let nalSize\n    for (let i = 0; i < numOfArrays; i++) {\n      nalUnitType = data[offset] & 0x3f\n      numNalus = (data[offset + 1] << 8) | data[offset + 2]\n\n      offset += 3\n\n      for (let j = 0; j < numNalus; j++) {\n        nalSize = (data[offset] << 8) | data[offset + 1]\n        offset += 2\n        if (!nalSize) continue\n        switch (nalUnitType) {\n          case 32: {\n            const vps = data.subarray(offset, offset + nalSize)\n            if (!vpsParsed) vpsParsed = HEVC.parseVPS(NALu.removeEPB(vps), hvcC)\n            vpsArr.push(vps)\n          }\n            break\n          case 33: {\n            const sps = data.subarray(offset, offset + nalSize)\n            if (!spsParsed) spsParsed = HEVC.parseSPS(NALu.removeEPB(sps), hvcC)\n            spsArr.push(sps)\n          }\n            break\n          case 34:\n            ppsArr.push(data.subarray(offset, offset + nalSize))\n            break\n          default:\n        }\n\n        offset += nalSize\n      }\n    }\n\n    return {\n      hvcC,\n      sps: spsParsed,\n      spsArr,\n      ppsArr,\n      vpsArr,\n      nalUnitSize\n    }\n  }\n\n  static parseVPS (unit, hvcC) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(12)\n    const vpsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(hvcC.numTemporalLayers || 0, vpsMaxSubLayersMinus1 + 1)\n    eg.readBits(17)\n    HEVC._parseProfileTierLevel(eg, vpsMaxSubLayersMinus1, hvcC)\n\n    return hvcC\n  }\n\n  static parseSPS (unit, hvcC = {}) {\n    hvcC = hvcC || {}\n    const eg = new ExpGolomb(unit)\n    eg.readUByte()\n    eg.readUByte()\n\n    eg.readBits(4)\n    const spsMaxSubLayersMinus1 = eg.readBits(3)\n    hvcC.numTemporalLayers = Math.max(spsMaxSubLayersMinus1 + 1, hvcC.numTemporalLayers || 0)\n    hvcC.temporalIdNested = eg.readBits(1)\n    HEVC._parseProfileTierLevel(eg, spsMaxSubLayersMinus1, hvcC)\n\n    eg.readUEG() // sps_seq_parameter_set_id\n\n    const chromaFormatIdc = hvcC.chromaFormatIdc = eg.readUEG()\n    let chromaFormat = 420\n    if (chromaFormatIdc <= 3) chromaFormat = [0, 420, 422, 444][chromaFormatIdc]\n\n    let separateColourPlaneFlag = 0\n    if (chromaFormatIdc === 3) {\n      separateColourPlaneFlag = eg.readBits(1)\n    }\n\n    let width = eg.readUEG() // pic_width_in_luma_samples\n    let height = eg.readUEG() // pic_height_in_luma_samples\n\n    const conformanceWindowFlag = eg.readBits(1)\n\n    let confWinLeftOffset\n    let confWinRightOffset\n    let confWinTopOffset\n    let confWinBottomOffset\n    if (conformanceWindowFlag === 1) {\n      confWinLeftOffset = eg.readUEG() // conf_win_left_offset\n      confWinRightOffset = eg.readUEG() // conf_win_right_offset\n      confWinTopOffset = eg.readUEG() // conf_win_top_offset\n      confWinBottomOffset = eg.readUEG() // conf_win_bottom_offset\n    }\n\n    hvcC.bitDepthLumaMinus8 = eg.readUEG() // bit_depth_luma_minus8\n    hvcC.bitDepthChromaMinus8 = eg.readUEG() // bit_depth_chroma_minus8\n\n    if (conformanceWindowFlag === 1) {\n      const subWidthC = (((chromaFormatIdc === 1) || (chromaFormatIdc === 2)) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      const subHeightC = ((chromaFormatIdc === 1) && (separateColourPlaneFlag === 0)) ? 2 : 1\n      width -= (subWidthC * (confWinRightOffset + confWinLeftOffset))\n      height -= (subHeightC * (confWinBottomOffset + confWinTopOffset))\n    }\n\n    return {\n      codec: 'hev1.1.6.L93.B0',\n      width,\n      height,\n      chromaFormat,\n      hvcC\n    }\n  }\n\n  static _parseProfileTierLevel (eg, maxSubLayersMinus1, hvcC) {\n    const generalTierFlag = hvcC.generalTierFlag || 0\n    hvcC.generalProfileSpace = eg.readBits(2)\n    hvcC.generalTierFlag = Math.max(eg.readBits(1), generalTierFlag)\n    hvcC.generalProfileIdc = Math.max(eg.readBits(5), hvcC.generalProfileIdc || 0)\n    hvcC.generalProfileCompatibilityFlags = eg.readBits(32)\n    hvcC.generalConstraintIndicatorFlags = [eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8), eg.readBits(8)]\n    const generalLevelIdc = eg.readBits(8)\n    if (generalTierFlag < hvcC.generalTierFlag) {\n      hvcC.generalLevelIdc = generalLevelIdc\n    } else {\n      hvcC.generalLevelIdc = Math.max(generalLevelIdc, hvcC.generalLevelIdc || 0)\n    }\n\n    const subLayerProfilePresentFlag = []\n    const subLayerLevelPresentFlag = []\n\n    if (maxSubLayersMinus1 > eg.bitsAvailable) {\n      throw new Error(`maxSubLayersMinus inavlid size ${maxSubLayersMinus1}`)\n    }\n\n    for (let j = 0; j < maxSubLayersMinus1; j++) {\n      subLayerProfilePresentFlag[j] = eg.readBits(1)\n      subLayerLevelPresentFlag[j] = eg.readBits(1)\n    }\n\n    if (maxSubLayersMinus1 > 0) {\n      eg.readBits((8 - maxSubLayersMinus1) * 2)\n    }\n\n    for (let i = 0; i < maxSubLayersMinus1; i++) {\n      if (subLayerProfilePresentFlag[i] !== 0) {\n        eg.readBits(2)\n        eg.readBits(1)\n        eg.readBits(5)\n\n        eg.readBits(16)\n        eg.readBits(16)\n\n        eg.readBits(4)\n\n        eg.readBits(16)\n        eg.readBits(16)\n        eg.readBits(12)\n      }\n      if (subLayerLevelPresentFlag[i] !== 0) {\n        eg.readBits(8)\n      }\n    }\n  }\n}\n","import { AudioCodecType, AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 500 // ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 1000 // ms\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 1000 // ms\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 200 // ms\nconst VIDEO_EXCETION_LOG_EMIT_DURATION = 5000 // 5s\nconst TRACK_BREACKED_CHECK_TIME = 5\n\nexport class FlvFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = 0\n    this._videoTimestampBreak = 0\n    this._lastVideoDuration = 0\n\n    // 在视频帧遇到下一个关键帧之前，如果音频时间戳发生了跳变，不能确定是否音视频都发生跳变还是单纯音频发生跳变.\n    // 这里记录关键帧标识, 从下一个关键帧开始，如果视频没有跳变，才能判断是只有音频发生了跳变\n    this._keyFrameInNextChunk = false\n\n    this._lastAudioExceptionGapDot = -Infinity\n    this._lastAudioExceptionOverlapDot = -Infinity\n    this._lastAudioExceptionLargeGapDot = -Infinity\n\n    this._lastVideoExceptionLargeGapDot = -Infinity\n    this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n  }\n\n  /**\n   * @param {number} startTime 点播seek到的时间点\n   * @param {boolean} discontinuity 是否换流\n   * @param {boolean} contiguous 前后chunk时间戳是否连续\n   */\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 1000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    if (discontinuity || !contiguous) {\n      this._videoLastSample = null\n      this._audioNextPts = undefined\n      this._videoNextDts = undefined\n      this._audioTimestampBreak = 0\n      this._videoTimestampBreak = 0\n      this._lastAudioExceptionGapDot = -Infinity\n      this._lastAudioExceptionOverlapDot = -Infinity\n      this._lastAudioExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionLargeGapDot = -Infinity\n      this._lastVideoExceptionChunkFirstDtsDot = -Infinity\n    }\n\n    if (discontinuity && !contiguous) {\n      this._baseDtsInited = false\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(audioTrack, videoTrack)\n    }\n\n    if (!contiguous && startTime) {\n      this._audioNextPts = this._videoNextDts = startTime\n    }\n\n    const resetBaseDts = this._baseDtsInited &&\n      (this._videoTimestampBreak || !this.videoTrack.exist()) &&\n      (this._audioTimestampBreak || !this.audioTrack.exist())\n\n    if (resetBaseDts) {\n      this._resetBaseDtsWhenStreamBreaked()\n    }\n\n    this._fixAudio(audioTrack)\n\n    this._keyFrameInNextChunk = false\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n      this.metadataTrack.flvScriptSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 1000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n      if (x.keyframe) this._keyFrameInNextChunk = true\n    })\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    } else if (videoTrack.length > 1) {\n      const first = videoTrack.samples[0]\n      const last = videoTrack.samples[samples.length - 1]\n      refSampleDurationInt = Math.floor((last.dts - first.dts) / (samples.length - 1))\n    } else {\n      refSampleDurationInt = this._lastVideoDuration || 40\n    }\n\n    const lastSample = samples.pop()\n\n    if (this._videoLastSample) {\n      samples.unshift(this._videoLastSample)\n    }\n\n    this._videoLastSample = lastSample\n\n    if (!samples.length) return\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      // emit large delta of first sample with expect\n      if (Math.abs(firstSample.dts - this._lastVideoExceptionChunkFirstDtsDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {\n        this._lastVideoExceptionChunkFirstDtsDot = firstSample.dts\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n          nextDts: this._videoNextDts,\n          firstSampleDts: firstSample.dts,\n          nextSampleDts: samples[1]?.dts,\n          sampleDuration: vDelta\n        })\n      }\n\n      // only video breaked\n      if (this._videoTimestampBreak >= TRACK_BREACKED_CHECK_TIME) {\n        this._videoNextDts = firstSample.dts\n        this._videoTimestampBreak = 0\n      } else {\n        // resolve first frame only\n        firstSample.dts += vDelta\n        firstSample.pts += vDelta\n        if (!this.audioTrack.exist()) {\n          this._videoTimestampBreak = 1\n        }\n      }\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (lastSample) {\n        sampleDuration = lastSample.dts - dts\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        this._videoTimestampBreak++\n        // emit stream breaked\n        if (Math.abs(dts - this._lastVideoExceptionLargeGapDot) > VIDEO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastVideoExceptionLargeGapDot = dts\n          videoTrack.warnings.push({\n            type: WarningType.LARGE_VIDEO_GAP,\n            time: dts / videoTrack.timescale,\n            dts,\n            originDts: samples[i].originDts,\n            nextDts: this._videoNextDts,\n            sampleDuration,\n            refSampleDuration: refSampleDurationInt\n          })\n        }\n\n        sampleDuration = refSampleDurationInt\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n      this._lastVideoDuration = sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n    if (!samples.length) return\n\n    // offset origin timestamp\n    samples.forEach(x => {\n      x.dts = x.pts -= this._baseDts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 1000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n    // calc baseDts base on new samples\n    const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n    if (!calc) return\n\n    // consider the expect dts for next frame\n    if (!this.audioTrack.exist()){\n      this._baseDts -= this._videoNextDts\n    } else if (!this.videoTrack.exist()){\n      this._baseDts -= this._audioNextPts\n    } else {\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n    }\n    this._videoTimestampBreak = 0\n    this._audioTimestampBreak = 0\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) {\n      audioTrack.sampleDuration = audioTrack.codecType === AudioCodecType.AAC\n        ? AAC.getFrameDuration(audioTrack.timescale, timescale)\n        : this._getG711Duration(audioTrack)\n    }\n    const refSampleDuration = audioTrack.sampleDuration\n\n    const sampleDurationInSampleRate = audioTrack.codecType === AudioCodecType.AAC ? 1024 : refSampleDuration * audioTrack.timescale / 1000\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      let nextPts = this._audioNextPts\n      const sample = samples[i]\n      let delta = sample.pts - nextPts\n\n      // only audio breaked\n      if (i === 0 && this._audioTimestampBreak >= TRACK_BREACKED_CHECK_TIME && this._keyFrameInNextChunk) {\n        nextPts = this._audioNextPts = sample.dts\n        delta = 0\n        this._audioTimestampBreak = 0\n      }\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = this._getSilentFrame(audioTrack) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_FILLED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            count,\n            nextPts,\n            refSampleDuration\n          })\n        }\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(this._audioNextPts + refSampleDuration) - Math.floor(this._audioNextPts), silentFrame, sampleDurationInSampleRate)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            nextPts,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) > MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak++\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts,\n              originPts: sample.originPts,\n              nextPts,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        sample.duration = sampleDurationInSampleRate\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n\n  _getG711Duration (track) {\n    const { sampleSize, channelCount, sampleRate } = track\n    const samp0 = track.samples[0]\n    if (!samp0) return\n    return samp0.data.byteLength * 2 / channelCount / (sampleSize / 8) / sampleRate * 1000\n  }\n\n  _getSilentFrame (track) {\n    if (track.codecType === AudioCodecType.AAC) return AAC.getSilentFrame(track.codec, track.channelCount)\n    return new Uint8Array(8 * track.sampleDuration * track.channelCount)\n  }\n}\n","import { UTF8 } from '../utils'\n\nexport class AMF {\n  static parse (data) {\n    if (data.length < 3) return\n\n    const ret = {}\n    const name = AMF._parseValue(new DataView(data.buffer, data.byteOffset, data.byteLength))\n    const value = AMF._parseValue(new DataView(data.buffer, data.byteOffset + name.size, data.byteLength - name.size))\n    ret[name.data] = value.data\n\n    return ret\n  }\n\n  static _parseValue (view) {\n    const dataLen = view.byteLength\n    const type = view.getUint8(0)\n    let offset = 1\n    let isEnd = false\n    let value\n\n    switch (type) {\n      case 0: // Number(Double) type\n        value = view.getFloat64(1)\n        offset += 8\n        break\n      case 1: { // Boolean type\n        value = !!view.getUint8(1)\n        offset += 1\n        break\n      }\n      case 2: { // String type\n        const { data, size } = AMF._parseString(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n        value = data\n        offset += size\n      }\n        break\n      case 3: { // Object(s) type\n        value = {}\n        let terminal = 0\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 4) { // 4 === type(UI8) + ScriptDataObjectEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) offset += 3\n        }\n      }\n        break\n      case 8: { // ECMA array type (Mixed array)\n        value = {}\n        offset += 4 // ECMAArrayLength(UI32)\n        let terminal = 0 // workaround for malformed MixedArrays which has missing ScriptDataObjectEnd\n        if ((view.getUint32(dataLen - 4) & 0x00FFFFFF) === 9) {\n          terminal = 3\n        }\n        while (offset < dataLen - 8) { // 8 === type(UI8) + ECMAArrayLength(UI32) + ScriptDataVariableEnd(UI24)\n          const { size, data, isEnd } = AMF._parseObject(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset - terminal))\n          if (isEnd) break\n          value[data.name] = data.value\n          offset += size\n        }\n        if (offset <= dataLen - 3) {\n          const marker = view.getUint32(offset - 1) & 0x00FFFFFF\n          if (marker === 9) {\n            offset += 3\n          }\n        }\n      }\n        break\n      case 9: // ScriptDataObjectEnd\n        value = undefined\n        offset = 1\n        isEnd = true\n        break\n      case 10: { // Strict array type\n        value = []\n        const strictArrayLength = view.getUint32(1)\n        offset += 4\n        for (let i = 0; i < strictArrayLength; i++) {\n          const { data, size } = AMF._parseValue(new DataView(view.buffer, view.byteOffset + offset, view.byteLength - offset))\n          value.push(data)\n          offset += size\n        }\n      }\n        break\n      case 11: { // Date type\n        const timestamp = view.getFloat64(offset) + view.getInt16(offset + 8) * 60000\n        value = new Date(timestamp)\n        offset += 10\n      }\n        break\n      case 12: { // Long string type\n        const length = view.getUint32(1)\n        offset += 4\n        value = ''\n        if (length > 0) {\n          value = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + offset, length))\n        }\n        offset += length\n      }\n        break\n      default:\n        offset = dataLen\n        break\n    }\n\n    return {\n      data: value,\n      size: offset,\n      isEnd\n    }\n  }\n\n  static _parseString (view) {\n    const length = view.getUint16(0)\n    let data = ''\n    if (length > 0) {\n      data = UTF8.decode(new Uint8Array(view.buffer, view.byteOffset + 2, length))\n    }\n\n    return {\n      data,\n      size: 2 + length\n    }\n  }\n\n  static _parseObject (view) {\n    if (view.byteLength < 3) return\n\n    const name = AMF._parseString(view)\n    const value = AMF._parseValue(new DataView(view.buffer, view.byteOffset + name.size, view.byteLength - name.size))\n\n    return {\n      data: {\n        name: name.data,\n        value: value.data\n      },\n      size: name.size + value.size,\n      isEnd: value.isEnd\n    }\n  }\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample, VideoCodecType, AudioCodecType, FlvScriptSample, SeiSample } from '../model'\nimport { FlvFixer } from './fixer'\nimport { concatUint8Array, Logger, readBig32 } from '../utils'\nimport { AAC, AVC, HEVC, NALu } from '../codec'\nimport { AMF } from './amf'\n\nconst logger = new Logger('FlvDemuxer')\n\n/**\n * @typedef {Object} DemuxResult\n * @property {VideoTrack} videoTrack\n * @property {AudioTrack} audioTrack\n * @property {MetadataTrack} metadataTrack\n */\n\nexport class FlvDemuxer {\n  _headerParsed = false\n  _remainingData = null\n  _gopId = 0\n  _needAddMetaBeforeKeyFrameNal = true // 标识H265流中关键帧Nal之前是否需要插入vps、sps、pps Nal\n\n  static AUDIO_RATE = [5500, 11000, 22000, 44000]\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new FlvFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false] 切流\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity || !contiguous) {\n      this._remainingData = null\n    }\n\n    if (discontinuity) {\n      this._headerParsed = false\n    }\n\n    if (discontinuity) {\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      metadataTrack.flvScriptSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingData) {\n        data = concatUint8Array(this._remainingData, data)\n        this._remainingData = null\n      }\n    }\n\n    if (!data.length) {\n      return {\n        videoTrack,\n        audioTrack,\n        metadataTrack\n      }\n    }\n\n    let offset = 0\n    if (!this._headerParsed) {\n      if (!FlvDemuxer.probe(data)) {\n        throw new Error('Invalid flv file')\n      }\n      audioTrack.present = ((data[4] & 4) >>> 2) !== 0\n      videoTrack.present = (data[4] & 1) !== 0\n      this._headerParsed = true\n      offset = readBig32(data, 5) + 4 // skip prev tag size\n    }\n\n    const dataLen = data.length\n\n    let tagType\n    let dataSize\n    let timestamp\n    let bodyData\n    let prevTagSize\n    while ((offset + 15) < dataLen) { // header and prev tag size\n      tagType = data[offset]\n      dataSize = (data[offset + 1] << 16) | (data[offset + 2] << 8) | data[offset + 3]\n      if (offset + 15 + dataSize > dataLen) break\n      timestamp = (\n        (data[offset + 7] << 24 >>> 0) +\n        (data[offset + 4] << 16) +\n        (data[offset + 5] << 8) +\n        data[offset + 6]\n      )\n\n      offset += 11\n      bodyData = data.subarray(offset, offset + dataSize)\n      if (tagType === 8) {\n        this._parseAudio(bodyData, timestamp)\n      } else if (tagType === 9) {\n        this._parseVideo(bodyData, timestamp)\n      } else if (tagType === 18) {\n        this._parseScript(bodyData, timestamp)\n      } else {\n        logger.warn(`Invalid tag type: ${tagType}`)\n      }\n\n      offset += dataSize\n      prevTagSize = readBig32(data, offset)\n      if (prevTagSize !== 11 + dataSize) {\n        logger.warn(`Invalid PrevTagSize ${prevTagSize} (${11 + dataSize})`)\n      }\n\n      offset += 4\n    }\n\n    if (offset < dataLen) {\n      this._remainingData = data.subarray(offset)\n    }\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 1000\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    if (!audioTrack.exist() && audioTrack.hasSample()) {\n      audioTrack.reset()\n    }\n    if (!videoTrack.exist() && videoTrack.hasSample()) {\n      videoTrack.reset()\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {DemuxResult}\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   * @returns {DemuxResult}\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (data[0] !== 0x46 || data[1] !== 0x4C || data[2] !== 0x56 || data[3] !== 0x01) {\n      return false\n    }\n    return readBig32(data, 5) >= 9\n  }\n\n  _parseAudio (data, pts) {\n    if (!data.length) return\n\n    const format = (data[0] & 0xf0) >>> 4\n    const track = this.audioTrack\n\n    if (\n      format !== 10 && // AAC\n      format !== 7 && // G.711 A-law logarithmic PCM\n      format !== 8 // G.711 mu-law logarithmic PCM\n    ) {\n      logger.warn(`Unsupported sound format: ${format}`)\n      track.reset()\n      return\n    }\n\n    if (format !== 10) {\n      const soundRate = (data[0] & 0x0c) >> 2\n      const soundSize = (data[0] & 0x02) >> 1\n      const soundType = (data[0] & 0x01)\n      track.sampleRate = FlvDemuxer.AUDIO_RATE[soundRate]\n      track.sampleSize = soundSize ? 16 : 8\n      track.channelCount = soundType + 1\n    }\n\n    if (format === 10) {\n      this._parseAac(data, pts)\n    } else {\n      this._parseG711(data, pts, format)\n    }\n  }\n\n  _parseG711 (data, pts, format) {\n    const track = this.audioTrack\n    track.codecType = format === 7 ? AudioCodecType.G711PCMA : AudioCodecType.G711PCMU\n    track.sampleRate = 8000\n    track.codec = track.codecType\n    track.samples.push(new AudioSample(pts, data.subarray(1)))\n  }\n\n  _parseAac (data, pts) {\n    const track = this.audioTrack\n    track.codecType = AudioCodecType.AAC\n\n    if (data[1] === 0) { // AACPacketType\n      const ret = AAC.parseAudioSpecificConfig(data.subarray(2))\n      if (ret) {\n        track.codec = ret.codec\n        track.channelCount = ret.channelCount\n        track.sampleRate = ret.sampleRate\n        track.config = ret.config\n        track.objectType = ret.objectType\n        track.sampleRateIndex = ret.samplingFrequencyIndex\n      } else {\n        track.reset()\n        logger.warn('Cannot parse AudioSpecificConfig', data)\n      }\n    } else if (data[1] === 1) { // Raw AAC frame data\n      if (pts === undefined || pts === null) return\n      track.samples.push(new AudioSample(pts, data.subarray(2)))\n    } else {\n      logger.warn(`Unknown AACPacketType: ${data[1]}`)\n    }\n  }\n\n  _parseVideo (data, dts) {\n    if (data.length < 6) return\n\n    const frameType = (data[0] & 0xf0) >>> 4\n    const codecId = data[0] & 0x0f\n\n    const track = this.videoTrack\n\n    if (\n      codecId !== 7 && // AVC\n      codecId !== 12 // HEVC\n    ) {\n      track.reset()\n      logger.warn(`Unsupported codecId: ${codecId}`)\n      return\n    }\n\n    const isHevc = codecId === 12\n    track.codecType = isHevc ? VideoCodecType.HEVC : VideoCodecType.AVC\n\n    const packetType = data[1]\n    const cts = (((data[2] << 16) | (data[3] << 8) | (data[4])) << 8) >> 8\n\n    if (packetType === 0) { // DecoderConfigurationRecord\n      const configData = data.subarray(5)\n      const ret = isHevc\n        ? HEVC.parseHEVCDecoderConfigurationRecord(configData)\n        : AVC.parseAVCDecoderConfigurationRecord(configData)\n      if (ret) {\n        const { hvcC, sps, ppsArr, spsArr, vpsArr, nalUnitSize } = ret\n        if (hvcC) {\n          track.hvcC = track.hvcC || hvcC\n        }\n        if (sps) {\n          track.codec = sps.codec\n          track.width = sps.width\n          track.height = sps.height\n          track.sarRatio = sps.sarRatio\n          track.fpsNum = sps.fpsNum\n          track.fpsDen = sps.fpsDen\n        }\n        if (spsArr.length) track.sps = spsArr\n        if (ppsArr.length) track.pps = ppsArr\n        if (vpsArr && vpsArr.length) track.vps = vpsArr\n        if (nalUnitSize) track.nalUnitSize = nalUnitSize\n      } else {\n        logger.warn(`Cannot parse ${isHevc ? 'HEVC' : 'AVC'}DecoderConfigurationRecord`, data)\n      }\n    } else if (packetType === 1) { // One or more NALUs\n      let units = NALu.parseAvcC(data.subarray(5), track.nalUnitSize)\n\n      units = this._checkAddMetaNalToUnits(isHevc, units, track)\n\n      if (units && units.length) {\n        const sample = new VideoSample(dts + cts, dts, units)\n        if (frameType === 1) {\n          sample.setToKeyframe()\n        }\n        track.samples.push(sample)\n\n        units.forEach(unit => {\n          const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n          switch (type) {\n            case 5: // IDR\n            case 16: // HEVC BLA_W_LP\n            case 17: // HEVC BLA_W_RADL\n            case 18: // HEVC BLA_N_LP\n            case 19: // HEVC IDR_W_RADL\n            case 20: // HEVC IDR_N_LP\n            case 21: // HEVC CRA_NUT\n            case 22: // HEVC RSV_IRAP_VCL22\n            case 23: // HEVC RSV_IRAP_VCL23\n              if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n              sample.setToKeyframe()\n              break\n            case 6: // SEI\n            case 39: // HEVC PREFIX_SEI\n            case 40: // HEVC SUFFIX_SEI\n              if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n              this.metadataTrack.seiSamples.push(new SeiSample(\n                NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n                dts + cts\n              ))\n              break\n            default:\n          }\n        })\n\n        if (sample.keyframe) {\n          this._gopId++\n        }\n        sample.gopId = this._gopId\n      } else {\n        logger.warn('Cannot parse NALUs', data)\n      }\n    } else if (packetType === 2) {\n      // AVC end of sequence, Empty\n    } else {\n      logger.warn(`Unknown AVCPacketType: ${packetType}`)\n    }\n  }\n\n  _checkAddMetaNalToUnits (hevc, units, track) {\n    if (!hevc || !this._needAddMetaBeforeKeyFrameNal) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    const nalTypes = units.map(x => (x[0] >>> 1) & 0x3f)\n\n    if (nalTypes.includes(32)) {\n      this._needAddMetaBeforeKeyFrameNal = false\n      return units\n    }\n\n    units.unshift(track.pps[0])\n    units.unshift(track.sps[0])\n    units.unshift(track.vps[0])\n\n    return units.filter(Boolean)\n  }\n\n  _parseScript (data, pts) {\n    this.metadataTrack.flvScriptSamples.push(new FlvScriptSample(AMF.parse(data), pts))\n  }\n}\n","import { AudioSample, WarningType } from '../model'\nimport { AAC } from '../codec'\nimport { isSafari } from '../utils'\n\nconst LARGE_AV_FIRST_FRAME_GAP = 90000 / 2 // 500ms\nconst AUDIO_GAP_OVERLAP_THRESHOLD_COUNT = 3\nconst MAX_SILENT_FRAME_DURATION = 90000 // 1s\nconst AUDIO_EXCETION_LOG_EMIT_DURATION = 5 * 90000 // 5s\nconst MAX_VIDEO_FRAME_DURATION = 90000 // 1s\nconst MAX_DTS_DELTA_WITH_NEXT_CHUNK = 90000 / 2 // 500ms\n\nexport class TsFixer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    this.metadataTrack = metadataTrack\n\n    this._baseDts = -1\n    this._baseDtsInited = false\n\n    this._audioNextPts = undefined\n    this._videoNextDts = undefined\n\n    this._audioTimestampBreak = false\n    this._videoTimestampBreak = false\n\n    this._lastAudioExceptionGapDot = 0\n    this._lastAudioExceptionOverlapDot = 0\n    this._lastAudioExceptionLargeGapDot = 0\n  }\n\n  fix (startTime = 0, discontinuity = false, contiguous = true) {\n    startTime = Math.round(startTime * 90000)\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    const vSamples = videoTrack.samples\n    const aSamples = audioTrack.samples\n\n    if (!vSamples.length && !aSamples.length) return\n\n    const firstVideoSample = vSamples[0]\n    const firstAudioSample = aSamples[0]\n\n    // consider av delta\n    let vaDelta = 0\n\n    if (vSamples.length && aSamples.length) {\n      vaDelta = firstVideoSample.dts - firstAudioSample.pts\n    }\n\n    if (!this._baseDtsInited) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n    }\n\n    // recalc baseDts\n    if (discontinuity) {\n      this._calculateBaseDts(this.audioTrack, this.videoTrack)\n      this._baseDts -= startTime\n    }\n\n    // id discontinue, recalc nextDts, consider av delta of firstframe\n    if (!contiguous) {\n      /**\n       *  segment.start = min(a, v)\n       *  segment.start\n       *      |\n       *      a\n       *       -- vaDelta --\n       *                   v\n       */\n      this._videoNextDts = vaDelta > 0 ? startTime + vaDelta : startTime\n      this._audioNextPts = vaDelta > 0 ? startTime : startTime - vaDelta\n\n      const vDeltaToNextDts = firstVideoSample ? firstVideoSample.dts - this._baseDts - this._videoNextDts : 0\n      const aDeltaToNextDts = firstAudioSample ? firstAudioSample.pts - this._baseDts - this._audioNextPts : 0\n\n      if (Math.abs(vDeltaToNextDts || aDeltaToNextDts) > MAX_VIDEO_FRAME_DURATION) {\n        this._calculateBaseDts(this.audioTrack, this.videoTrack)\n        this._baseDts -= startTime\n      }\n    }\n\n    this._resetBaseDtsWhenStreamBreaked()\n\n    // fix audio first\n    this._fixAudio(audioTrack)\n\n    this._fixVideo(videoTrack)\n\n    if (this.metadataTrack.exist()) {\n      const timescale = this.metadataTrack.timescale\n      this.metadataTrack.seiSamples.forEach(s => {\n        s.pts = s.originPts - this._baseDts\n        s.time = Math.max(0, s.pts) / timescale\n      })\n    }\n\n    if (videoTrack.samples.length) {\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioTrack.samples.length) {\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].pts * audioTrack.timescale / 90000\n    }\n  }\n\n  _fixVideo (videoTrack) {\n    const samples = videoTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.dts -= this._baseDts\n      x.pts -= this._baseDts\n    })\n\n    if (this._videoNextDts === undefined) {\n      const samp0 = samples[0]\n      this._videoNextDts = samp0.dts\n    }\n\n    const len = samples.length\n    let sampleDuration = 0\n    const firstSample = samples[0]\n    const nextSample = samples[1]\n    const vDelta = this._videoNextDts - firstSample.dts\n\n    if (Math.abs(vDelta) > MAX_DTS_DELTA_WITH_NEXT_CHUNK) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_VIDEO_GAP_BETWEEN_CHUNK,\n        nextDts: this._videoNextDts / 90,\n        firstSampleDts: firstSample.dts / 90,\n        nextSampleDts: (samples[1]?.dts || 0) / 90,\n        sampleDuration: vDelta / 90\n      })\n\n      // resolve first frame first\n      firstSample.dts += vDelta\n      firstSample.pts += vDelta\n\n\n      // check to ajust the whole segment\n      if (nextSample && Math.abs(nextSample.dts - firstSample.dts) > MAX_VIDEO_FRAME_DURATION) {\n        this._videoTimestampBreak = true\n        samples.forEach((x, i) => {\n          if (i === 0) return\n          x.dts += vDelta\n          x.pts += vDelta\n        })\n      } else {\n        for (let i = 1; i < len - 1; i++) {\n          const dts = samples[i]?.dts\n          const prevDts = samples[i - 1 ].dts\n          if (dts && dts - prevDts < 0) {\n            samples[i].dts += vDelta\n            samples[i].pts += vDelta\n          }\n        }\n      }\n    }\n\n    let refSampleDurationInt\n    if (videoTrack.fpsNum && videoTrack.fpsDen) {\n      refSampleDurationInt = videoTrack.timescale * (videoTrack.fpsDen / videoTrack.fpsNum)\n    } else {\n      const first = videoTrack.samples[0]\n      const second = videoTrack.samples[1]\n      // 100ms default\n      refSampleDurationInt = len === 1 ? 9000 : Math.floor((second.dts - first.dts))\n    }\n\n    for (let i = 0; i < len; i++) {\n      const dts = samples[i].dts\n      const nextSample = samples[i + 1]\n      if (i < len - 1) {\n        sampleDuration = nextSample.dts - dts\n      } else if (samples[i - 1]) {\n        sampleDuration = Math.min(dts - samples[i - 1].dts, refSampleDurationInt)\n      } else {\n        sampleDuration = refSampleDurationInt\n      }\n\n      if (sampleDuration > MAX_VIDEO_FRAME_DURATION || sampleDuration < 0) {\n        // dts exception of adjacent frame\n        this._videoTimestampBreak = true\n\n        // check if only video breaked!\n        sampleDuration = this._audioTimestampBreak ? refSampleDurationInt : Math.max(sampleDuration, 30 * 90) // 30ms\n\n        // check if sample breaked within current fragment\n        const expectFragEnd = (this._audioNextPts || 0)\n        if (nextSample && nextSample.dts > expectFragEnd) {\n          sampleDuration = refSampleDurationInt\n        }\n\n        videoTrack.warnings.push({\n          type: WarningType.LARGE_VIDEO_GAP,\n          time: dts / videoTrack.timescale,\n          dts,\n          originDts: samples[i].originDts,\n          nextDts: this._videoNextDts,\n          sampleDuration,\n          refSampleDuration: refSampleDurationInt\n        })\n      }\n\n      samples[i].duration = sampleDuration\n      this._videoNextDts += sampleDuration\n    }\n  }\n\n  _fixAudio (audioTrack) {\n    const samples = audioTrack.samples\n\n    if (!samples.length) return\n    samples.forEach(x => {\n      x.pts -= this._baseDts\n      x.dts = x.pts\n    })\n\n    this._doFixAudioInternal(audioTrack, samples, 90000)\n  }\n\n  _calculateBaseDts (audioTrack, videoTrack) {\n    const audioSamps = audioTrack.samples\n    const videoSamps = videoTrack.samples\n\n    if (!audioSamps.length && !videoSamps.length) {\n      return false\n    }\n\n    let audioBasePts = Infinity\n    let videoBaseDts = Infinity\n\n    if (audioSamps.length) {\n      audioTrack.baseDts = audioBasePts = audioSamps[0].pts\n    }\n\n    if (videoSamps.length) {\n      videoTrack.baseDts = videoBaseDts = videoSamps[0].dts\n    }\n\n    this._baseDts = Math.min(audioBasePts, videoBaseDts)\n\n    const delta = videoBaseDts - audioBasePts\n\n    if (Number.isFinite(delta) && Math.abs(delta) > LARGE_AV_FIRST_FRAME_GAP) {\n      videoTrack.warnings.push({\n        type: WarningType.LARGE_AV_SHIFT,\n        videoBaseDts,\n        audioBasePts,\n        baseDts: this._baseDts,\n        delta\n      })\n    }\n\n    this._baseDtsInited = true\n    return true\n  }\n\n  _resetBaseDtsWhenStreamBreaked () {\n    if (this._baseDtsInited && this._videoTimestampBreak && this._audioTimestampBreak) {\n      /**\n       * timestamp breaked\n       *                     _audioNextDts\n       *  ---------------------|\n       * (_baseDts)          _videoNextDts\n       * ----------------------|\n       *                        <----------------\n       *                                       nextVideo.dts\n       * ----------------------------------------|\n       *                                       nextAudio.dts\n       * ---------------------------------------|\n       */\n\n      // calc baseDts base on new samples\n      const calc = this._calculateBaseDts(this.audioTrack, this.videoTrack)\n\n      if (!calc) return\n\n      // consider the expect dts for next frame\n      this._baseDts -= Math.min(this._audioNextPts, this._videoNextDts)\n      this._audioLastSample = null\n      this._videoLastSample = null\n      this._videoTimestampBreak = false\n      this._audioTimestampBreak = false\n    }\n  }\n\n  _doFixAudioInternal (audioTrack, samples, timescale) {\n    if (!audioTrack.sampleDuration) audioTrack.sampleDuration = AAC.getFrameDuration(audioTrack.timescale, timescale)\n    const refSampleDuration = audioTrack.sampleDuration\n\n    if (this._audioNextPts === undefined) {\n      const samp0 = samples[0]\n      this._audioNextPts = samp0.pts\n    }\n\n    for (let i = 0; i < samples.length; i++) {\n      const nextPts = this._audioNextPts\n      const sample = samples[i]\n      const delta = sample.pts - nextPts\n\n      // fill frames\n      // delta >= 3 * refSampleDurationInt\n      // delta <= 500s\n      if (!this._audioTimestampBreak && delta >= AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta <= MAX_SILENT_FRAME_DURATION && !isSafari) {\n        const silentFrame = AAC.getSilentFrame(audioTrack.codec, audioTrack.channelCount) || samples[0].data.subarray()\n        const count = Math.floor(delta / refSampleDuration)\n\n        if (Math.abs(sample.pts - this._lastAudioExceptionGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionGapDot = sample.pts\n        }\n\n        audioTrack.warnings.push({\n          type: WarningType.AUDIO_FILLED,\n          pts: sample.pts,\n          originPts: sample.originPts,\n          count,\n          nextPts,\n          refSampleDuration\n        })\n\n        for (let j = 0; j < count; j++) {\n          const silentSample = new AudioSample(Math.floor(nextPts), silentFrame)\n          silentSample.originPts = Math.floor(this._baseDts + nextPts)\n          samples.splice(i, 0, silentSample)\n          this._audioNextPts += refSampleDuration\n          i++\n        }\n\n        i--\n        // delta  <= -3 * refSampleDurationInt\n        // delta  >= -500ms\n      } else if (delta <= -AUDIO_GAP_OVERLAP_THRESHOLD_COUNT * refSampleDuration && delta >= -1 * MAX_SILENT_FRAME_DURATION) {\n        // need discard frames\n        if (Math.abs(sample.pts - this._lastAudioExceptionOverlapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n          this._lastAudioExceptionOverlapDot = sample.pts\n          audioTrack.warnings.push({\n            type: WarningType.AUDIO_DROPPED,\n            pts: sample.pts,\n            originPts: sample.originPts,\n            nextPts,\n            refSampleDuration\n          })\n        }\n        samples.splice(i, 1)\n        i--\n      } else {\n        if (Math.abs(delta) >= MAX_SILENT_FRAME_DURATION) {\n          this._audioTimestampBreak = true\n\n          if (Math.abs(sample.pts - this._lastAudioExceptionLargeGapDot) > AUDIO_EXCETION_LOG_EMIT_DURATION) {\n            this._lastAudioExceptionLargeGapDot = sample.pts\n            audioTrack.warnings.push({\n              type: WarningType.LARGE_AUDIO_GAP,\n              time: sample.pts / 1000,\n              pts: sample.pts,\n              originPts: sample.originPts,\n              nextPts,\n              sampleDuration: delta,\n              refSampleDuration\n            })\n          }\n        }\n\n        sample.dts = sample.pts = nextPts\n        this._audioNextPts += refSampleDuration\n      }\n    }\n  }\n}\n","import { TsFixer } from './fixer'\nimport { AVC, AAC, HEVC, NALu } from '../codec'\nimport { VideoSample, AudioSample, VideoCodecType, VideoTrack, AudioTrack, MetadataTrack, SeiSample } from '../model'\nimport { Logger, concatUint8Array } from '../utils'\n\nconst logger = new Logger('TsDemuxer')\n\nexport class TsDemuxer {\n  _pmtId = -1\n  _remainingPacketData = null\n  _videoPesData = []\n  _audioPesData = []\n  _gopId = 0\n\n  /**\n   * @param {VideoTrack} [videoTrack]\n   * @param {AudioTrack} [audioTrack]\n   * @param {MetadataTrack} [metadataTrack]\n   */\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this._fixer = new TsFixer(this.videoTrack, this.audioTrack, this.metadataTrack)\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @returns {import('../flv').DemuxResult}\n   */\n  demux (data, discontinuity = false, contiguous = true) {\n    const { audioTrack, videoTrack, metadataTrack } = this\n\n    if (discontinuity) {\n      this._pmtId = -1\n      videoTrack.reset()\n      audioTrack.reset()\n      metadataTrack.reset()\n    }\n\n    if (!contiguous || discontinuity) {\n      this._remainingPacketData = null\n      this._videoPesData = []\n      this._audioPesData = []\n    } else {\n      videoTrack.samples = []\n      audioTrack.samples = []\n      metadataTrack.seiSamples = []\n      videoTrack.warnings = []\n      audioTrack.warnings = []\n\n      if (this._remainingPacketData) {\n        data = concatUint8Array(this._remainingPacketData, data)\n        this._remainingPacketData = null\n      }\n    }\n\n    let dataLen = data.length\n    const remainingLength = dataLen % 188\n    if (remainingLength) {\n      this._remainingPacketData = data.subarray(dataLen - remainingLength)\n      dataLen -= remainingLength\n    }\n\n    let videoPid = videoTrack.pid\n    let audioPid = audioTrack.pid\n\n    for (let start = 0; start < dataLen; start += 188) {\n      if (data[start] !== 0x47) throw new Error('TS packet did not start with 0x47')\n      const payloadUnitStartIndicator = !!(data[start + 1] & 0x40)\n      const pid = ((data[start + 1] & 0x1f) << 8) + data[start + 2]\n      const adaptationFiledControl = (data[start + 3] & 0x30) >> 4\n\n      let offset\n      if (adaptationFiledControl > 1) {\n        offset = start + 5 + data[start + 4]\n        if (offset === start + 188) continue\n      } else {\n        offset = start + 4\n      }\n\n      switch (pid) {\n        case 0: // PAT\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          this._pmtId = ((data[offset + 10] & 0x1f) << 8) | data[offset + 11]\n          break\n        case this._pmtId: {\n          if (payloadUnitStartIndicator) offset += data[offset] + 1\n          const tableEnd = offset + 3 + (((data[offset + 1] & 0x0f) << 8) | data[offset + 2]) - 4\n          const programInfoLength = ((data[offset + 10] & 0x0f) << 8) | data[offset + 11]\n          offset += 12 + programInfoLength\n\n          while (offset < tableEnd) {\n            const esPid = ((data[offset + 1] & 0x1f) << 8) | data[offset + 2]\n            switch (data[offset]) {\n              case 0x0f: // AAC ADTS\n                audioTrack.pid = audioPid = esPid\n                break\n              case 0x1b: // AVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.AVC\n                videoTrack.pid = videoPid = esPid\n                break\n              case 0x24: // HEVC\n                if (videoPid !== -1) break\n                videoTrack.codecType = VideoCodecType.HEVC\n                videoTrack.pid = videoPid = esPid\n                break\n              default:\n                logger.warn(`Unsupported stream. type: ${data[offset]}, pid: ${esPid}`)\n            }\n\n            offset += (((data[offset + 3] & 0x0f) << 8) | data[offset + 4]) + 5\n          }\n        }\n          break\n        case videoPid:\n          if (payloadUnitStartIndicator && this._videoPesData.length) {\n            this._parseVideoData()\n          }\n          this._videoPesData.push(data.subarray(offset, start + 188))\n          break\n        case audioPid:\n          if (payloadUnitStartIndicator && this._audioPesData.length) {\n            this._parseAudioData()\n          }\n          this._audioPesData.push(data.subarray(offset, start + 188))\n          break\n        case 17:\n        case 0x1fff:\n          break\n        default:\n          logger.warn(`Unknown pid: ${pid}`)\n      }\n    }\n\n    this._parseVideoData()\n    this._parseAudioData()\n\n    audioTrack.formatTimescale = videoTrack.formatTimescale = videoTrack.timescale = metadataTrack.timescale = 90000\n\n    audioTrack.timescale = audioTrack.sampleRate || 0\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack\n    }\n  }\n\n  /**\n   * @param {number} [startTime=0]\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   */\n  fix (startTime, discontinuity, contiguous) {\n    this._fixer.fix(startTime, discontinuity, contiguous)\n    return {\n      videoTrack: this.videoTrack,\n      audioTrack: this.audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  /**\n   * @param {Uint8Array} data\n   * @param {boolean} [discontinuity=false]\n   * @param {boolean} [contiguous=true]\n   * @param {number} [startTime=0]\n   */\n  demuxAndFix (data, discontinuity, contiguous, startTime) {\n    this.demux(data, discontinuity, contiguous)\n    return this.fix(startTime, discontinuity, contiguous)\n  }\n\n  /**\n   * @param { Uint8Array } data\n   * @returns {boolean}\n   */\n  static probe (data) {\n    if (!data.length) return false\n    return data[0] === 0x47 && data[188] === 0x47 && data[376] === 0x47\n  }\n\n  _parseVideoData () {\n    if (!this._videoPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._videoPesData))\n    if (!pes) {\n      logger.warn('Cannot parse video pes', this._videoPesData)\n      return\n    }\n\n    const units = NALu.parseAnnexB(pes.data)\n    if (units) {\n      this._createVideoSample(units, pes.pts, pes.dts)\n    } else {\n      logger.warn('Cannot parse avc units', pes)\n    }\n\n    this._videoPesData = []\n  }\n\n  _createVideoSample (units, pts, dts) {\n    if (!units.length) return\n    const track = this.videoTrack\n    const isHevc = track.codecType === VideoCodecType.HEVC\n\n    const sample = new VideoSample(pts, dts)\n    units.forEach((unit) => {\n      const type = isHevc ? (unit[0] >>> 1) & 0x3f : unit[0] & 0x1f\n      switch (type) {\n        case 5: // IDR\n        case 16: // HEVC BLA_W_LP\n        case 17: // HEVC BLA_W_RADL\n        case 18: // HEVC BLA_N_LP\n        case 19: // HEVC IDR_W_RADL\n        case 20: // HEVC IDR_N_LP\n        case 21: // HEVC CRA_NUT\n        case 22: // HEVC RSV_IRAP_VCL22\n        case 23: // HEVC RSV_IRAP_VCL23\n          if ((!isHevc && type !== 5) || (isHevc && type === 5)) break\n          sample.setToKeyframe()\n          this._gopId++\n          break\n        case 6: // SEI\n        case 39: // HEVC PREFIX_SEI\n        case 40: // HEVC SUFFIX_SEI\n          if ((!isHevc && type !== 6) || (isHevc && type === 6)) break\n          this.metadataTrack.seiSamples.push(new SeiSample(\n            NALu.parseSEI(NALu.removeEPB(unit), isHevc),\n            pts\n          ))\n          // fix 分割nal之前只要sei信息被当做单独一个sample\n          return\n        case 32: // HEVC VPS\n          if (!isHevc) break\n          if (!track.vps.length) {\n            const hvcC = HEVC.parseVPS(NALu.removeEPB(unit), track.hvcC)\n            track.hvcC = track.hvcC || hvcC\n            track.vps = [unit]\n          }\n          break\n        case 7: // SPS\n        case 33: // HEVC SPS\n          if ((!isHevc && type !== 7) || (isHevc && type === 7)) break\n          if (!track.sps.length) {\n            const data = NALu.removeEPB(unit)\n            const spsInfo = isHevc ? HEVC.parseSPS(data, track.hvcC) : AVC.parseSPS(data)\n            track.sps = [unit]\n            track.hvcC = track.hvcC || spsInfo.hvcC\n            track.codec = spsInfo.codec\n            track.width = spsInfo.width\n            track.height = spsInfo.height\n            track.sarRatio = spsInfo.sarRatio\n            track.fpsNum = spsInfo.fpsNum\n            track.fpsDen = spsInfo.fpsDen\n          }\n          break\n        case 8: // PPS\n        case 34: // HEVC PPS\n          if ((!isHevc && type !== 8) || (isHevc && type === 8)) break\n          if (!track.pps.length) track.pps = [unit]\n          break\n        case 9: // AUD\n        case 35: // HEVC AUD\n          // if ((!isHevc && type !== 9) || (isHevc && type === 9)) break\n          // sample.gopId = this._gopId\n          // if (sample.units.length && !keyFrame) {\n          //   this._pushVideoSample(track, sample)\n          //   sample = this.prevAvcSample = new VideoSample(pts, dts)\n          // }\n          break\n        default:\n      }\n      sample.units.push(unit)\n    })\n    sample.gopId = this._gopId\n    this._pushVideoSample(track, sample)\n  }\n\n  _pushVideoSample (track, sample) {\n    if (sample.units.length) {\n      if (sample.pts === null || sample.pts === undefined) {\n        logger.warn('Video sample no pts', sample)\n        const lastSample = track.samples[track.samples.length - 1]\n        if (lastSample) {\n          sample.pts = lastSample.pts\n          sample.dts = lastSample.dts\n        } else {\n          logger.warn('Drop video sample', sample)\n        }\n      } else {\n        track.samples.push(sample)\n      }\n    }\n  }\n\n  _parseAudioData () {\n    if (!this._audioPesData.length) return\n    const pes = TsDemuxer._parsePES(concatUint8Array(...this._audioPesData))\n    if (!pes) {\n      logger.warn('Cannot parse audio pes', this._audioPesData)\n      return\n    }\n\n    this._parseAacData(pes)\n\n    this._audioPesData = []\n  }\n\n  _parseAacData (pes) {\n    const track = this.audioTrack\n    let pts = pes.pts\n    if (pts === null || pts === undefined) {\n      logger.warn('AAC pes not pts', track)\n      if (!track.samples.length || !track.sampleRate) {\n        return\n      }\n      pts = track.samples[track.samples.length - 1].pts + AAC.getFrameDuration(track.sampleRate)\n    }\n\n    const ret = AAC.parseADTS(pes.data, pts)\n    if (ret) {\n      track.codec = ret.codec\n      track.channelCount = ret.channelCount\n      track.sampleRate = ret.sampleRate\n      track.objectType = ret.objectType\n      track.sampleRateIndex = ret.samplingFrequencyIndex\n      track.config = ret.config\n      track.samples.push(...ret.frames.map((s) => new AudioSample(s.pts, s.data)))\n\n      if (ret.skip) {\n        logger.warn(`Skip aac adts ${ret.skip} bits`)\n      }\n      if (ret.remaining) {\n        logger.warn(`Remaining aac adts ${ret.remaining} bits`)\n      }\n    } else {\n      logger.warn('Cannot parse aac adts', pes)\n    }\n  }\n\n  static _parsePES (data) {\n    const headerDataLen = data[8]\n    if (headerDataLen === null || headerDataLen === undefined || data.length < (headerDataLen + 9)) return\n    const startPrefix = data[0] << 16 | data[1] << 8 | data[2]\n    if (startPrefix !== 1) return\n    const pesLen = (data[4] << 8) + data[5]\n    if (pesLen && pesLen > data.length - 6) return\n\n    let pts\n    let dts\n    const ptsDtsFlags = data[7]\n    if (ptsDtsFlags & 0xc0) {\n      pts = (data[9] & 0x0e) * 536870912 +\n        (data[10] & 0xff) * 4194304 +\n        (data[11] & 0xfe) * 16384 +\n        (data[12] & 0xff) * 128 +\n        (data[13] & 0xfe) / 2\n\n      if (ptsDtsFlags & 0x40) {\n        dts = (data[14] & 0x0e) * 536870912 +\n          (data[15] & 0xff) * 4194304 +\n          (data[16] & 0xfe) * 16384 +\n          (data[17] & 0xff) * 128 +\n          (data[18] & 0xfe) / 2\n        if (pts - dts > 60 * 90000) pts = dts\n      } else {\n        dts = pts\n      }\n    }\n\n    return { data: data.subarray(9 + headerDataLen), pts, dts }\n  }\n}\n","import { AudioCodecType, VideoCodecType } from '../model'\nimport { getAvcCodec, readBig16, readBig24, readBig32, readBig64 } from '../utils'\nimport { AAC } from '../codec'\nexport class MP4Parser {\n  static findBox (data, names, start = 0) {\n    const ret = []\n    if (!data) return ret\n\n    let size = 0\n    let type = ''\n    let headerSize = 0\n    while (data.length > 7) {\n      size = readBig32(data)\n      type = String.fromCharCode.apply(null, data.subarray(4, 8))\n      headerSize = 8\n      if (size === 1) {\n        size = readBig64(data, 8)\n        headerSize += 8\n      } else if (!size) {\n        size = data.length\n      }\n      if (!names[0] || type === names[0]) {\n        const subData = data.subarray(0, size)\n        if (names.length < 2) {\n          ret.push({\n            start,\n            size,\n            headerSize,\n            type,\n            data: subData\n          })\n        } else {\n          return MP4Parser.findBox(subData.subarray(headerSize), names.slice(1), start + headerSize)\n        }\n      }\n\n      start += size\n      data = data.subarray(size)\n    }\n\n    return ret\n  }\n\n  static tfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.trackId = readBig32(data)\n      let start = 4\n      const baseDataOffsetPresent = (ret.flags & 0xff) & 0x01\n      const sampleDescriptionIndexPresent = (ret.flags & 0xff) & 0x02\n      const defaultSampleDurationPresent = (ret.flags & 0xff) & 0x08\n      const defaultSampleSizePresent = (ret.flags & 0xff) & 0x10\n      const defaultSampleFlagsPresent = (ret.flags & 0xff) & 0x20\n\n      if (baseDataOffsetPresent) {\n        start += 4 // truncate top 4 bytes\n        ret.baseDataOffset = readBig32(data, start)\n        start += 4\n      }\n      if (sampleDescriptionIndexPresent) {\n        ret.sampleDescriptionIndex = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleDurationPresent) {\n        ret.defaultSampleDuration = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleSizePresent) {\n        ret.defaultSampleSize = readBig32(data, start)\n        start += 4\n      }\n      if (defaultSampleFlagsPresent) {\n        ret.defaultSampleFlags = readBig32(data, start)\n      }\n    })\n  }\n\n  static sidx (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      ret.reference_ID = readBig32(data, start)// stream.readUint32();\n      start += 4\n      ret.timescale = readBig32(data, start)\n      start += 4\n      if (ret.version === 0) {\n        ret.earliest_presentation_time = readBig32(data, start)\n        start += 4\n        ret.first_offset = readBig32(data, start)\n        start += 4\n      } else {\n        ret.earliest_presentation_time = readBig64(data, start)\n        start += 8\n        ret.first_offset = readBig64(data, start)\n        start += 8\n      }\n      start += 2\n      ret.references = []\n      const count = readBig16(data, start)\n      start += 2\n      for (let i = 0; i < count; i++) {\n        const ref = {}\n        ret.references.push(ref)\n        let tmp32 = readBig32(data, start)\n        start += 4\n        ref.reference_type = (tmp32 >> 31) & 0x1\n        ref.referenced_size = tmp32 & 0x7FFFFFFF\n        ref.subsegment_duration = readBig32(data, start)\n        start += 4\n        tmp32 = readBig32(data, start)\n        start += 4\n        ref.starts_with_SAP = (tmp32 >> 31) & 0x1\n        ref.SAP_type = (tmp32 >> 28) & 0x7\n        ref.SAP_delta_time = tmp32 & 0xFFFFFFF\n      }\n    })\n  }\n\n  static moov (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mvhd = MP4Parser.mvhd(MP4Parser.findBox(data, ['mvhd'], start)[0])\n      ret.trak = MP4Parser.findBox(data, ['trak'], start).map(trak => MP4Parser.trak(trak))\n      ret.pssh = MP4Parser.pssh(MP4Parser.findBox(data, ['pssh'], start)[0])\n    })\n  }\n\n  static mvhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      ret.nextTrackId = readBig32(data, start + 76)\n    })\n  }\n\n  static trak (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tkhd = MP4Parser.tkhd(MP4Parser.findBox(data, ['tkhd'], start)[0])\n      ret.mdia = MP4Parser.mdia(MP4Parser.findBox(data, ['mdia'], start)[0])\n    })\n  }\n\n  static tkhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.trackId = readBig32(data, 16)\n        ret.duration = readBig64(data, 24)\n        start += 32\n      } else {\n        ret.trackId = readBig32(data, 8)\n        ret.duration = readBig32(data, 16)\n        start += 20\n      }\n      ret.width = readBig32(data, start + 52)\n      ret.height = readBig32(data, start + 56)\n    })\n  }\n\n  static mdia (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mdhd = MP4Parser.mdhd(MP4Parser.findBox(data, ['mdhd'], start)[0])\n      ret.hdlr = MP4Parser.hdlr(MP4Parser.findBox(data, ['hdlr'], start)[0])\n      ret.minf = MP4Parser.minf(MP4Parser.findBox(data, ['minf'], start)[0])\n    })\n  }\n\n  static mdhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      if (ret.version === 1) {\n        ret.timescale = readBig32(data, 16)\n        ret.duration = readBig64(data, 20)\n        start += 28\n      } else {\n        ret.timescale = readBig32(data, 8)\n        ret.duration = readBig32(data, 12)\n        start += 16\n      }\n      const lang = readBig16(data, start)\n      ret.language = String.fromCharCode(((lang >> 10) & 0x1F) + 0x60, ((lang >> 5) & 0x1F) + 0x60, (lang & 0x1F) + 0x60)\n    })\n  }\n\n  static hdlr (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 0) {\n        ret.handlerType = String.fromCharCode.apply(null, data.subarray(4, 8))\n      }\n    })\n  }\n\n  static minf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.vmhd = MP4Parser.vmhd(MP4Parser.findBox(data, ['vmhd'], start)[0])\n      ret.smhd = MP4Parser.smhd(MP4Parser.findBox(data, ['smhd'], start)[0])\n      ret.stbl = MP4Parser.stbl(MP4Parser.findBox(data, ['stbl'], start)[0])\n    })\n  }\n\n  static vmhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.graphicsmode = readBig16(data)\n      ret.opcolor = [readBig16(data, 2), readBig16(data, 4), readBig16(data, 6)]\n    })\n  }\n\n  static smhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.balance = readBig16(data)\n    })\n  }\n\n  static stbl (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.stsd = MP4Parser.stsd(MP4Parser.findBox(data, ['stsd'], start)[0])\n      ret.stts = MP4Parser.stts(MP4Parser.findBox(data, ['stts'], start)[0])\n      ret.ctts = MP4Parser.ctts(MP4Parser.findBox(data, ['ctts'], start)[0])\n      ret.stsc = MP4Parser.stsc(MP4Parser.findBox(data, ['stsc'], start)[0])\n      ret.stsz = MP4Parser.stsz(MP4Parser.findBox(data, ['stsz'], start)[0])\n      ret.stco = MP4Parser.stco(MP4Parser.findBox(data, ['stco'], start)[0])\n      if (!ret.stco) {\n        ret.co64 = MP4Parser.co64(MP4Parser.findBox(data, ['co64'], start)[0])\n        ret.stco = ret.co64\n      }\n      const default_IV_size = ret.stsd.entries[0]?.sinf?.schi?.tenc.default_IV_size\n      ret.stss = MP4Parser.stss(MP4Parser.findBox(data, ['stss'], start)[0])\n      ret.senc = MP4Parser.senc(MP4Parser.findBox(data, ['senc'], start)[0], default_IV_size)\n    })\n  }\n\n  static senc (box, iv = 8) {\n    return parseBox(box, true, (ret, data) => {\n      let start = 0\n      const sampleCount = readBig32(data, start)\n      start += 4\n      ret.samples = []\n      for (let i = 0; i < sampleCount; i++) {\n        const sample = {}\n        sample.InitializationVector = []\n        for (let j = 0; j < iv; j++){\n          sample.InitializationVector[j] = data[start + j]\n        }\n        start += iv\n        if (ret.flags & 0x2) {\n          sample.subsamples = []\n          const subsampleCount = readBig16(data, start)\n          start += 2\n          for (let j = 0; j < subsampleCount; j++) {\n            const subsample = {}\n            subsample.BytesOfClearData = readBig16(data, start)\n            start += 2\n            subsample.BytesOfProtectedData = readBig32(data, start)\n            start += 4\n            sample.subsamples.push(subsample)\n          }\n        }\n        ret.samples.push(sample)\n      }\n    })\n  }\n\n  static pssh (box) {\n    return parseBox(box, true, (ret, data) => {\n      const keyIds = []\n      const systemId = []\n      let start = 0\n      for (let i = 0; i < 16; i++) {\n        systemId.push(toHex(data[start + i]))\n      }\n      start += 16\n      if (ret.version > 0) {\n        const numKeyIds = readBig32(data, start)\n        start += 4\n        for (let i = 0; i < ('' + numKeyIds).length; i++) {\n          for (let j = 0; j < 16; j++) {\n            const keyId = data[start]\n            start += 1\n            keyIds.push(toHex(keyId))\n          }\n        }\n      }\n      const dataSize = readBig32(data, start)\n      ret.data_size = dataSize\n      start += 4\n      ret.kid = keyIds\n      ret.system_id = systemId\n      ret.buffer = data\n    })\n  }\n\n  static stsd (box) {\n    return parseBox(box, true, (ret, data, start) => {\n      ret.entryCount = readBig32(data)\n      ret.entries = MP4Parser.findBox(data.subarray(4), [], start + 4).map(b => {\n        switch (b.type) {\n          case 'avc1':\n          case 'avc2':\n          case 'avc3':\n          case 'avc4':\n            return MP4Parser.avc1(b)\n          case 'hvc1':\n          case 'hev1':\n            return MP4Parser.hvc1(b)\n          case 'mp4a':\n            return MP4Parser.mp4a(b)\n          case 'alaw':\n          case 'ulaw':\n            return MP4Parser.alaw(b)\n          case 'enca':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.channelCount = readBig16(data, 16)\n              ret.samplesize = readBig16(data, 18)\n              ret.sampleRate = (readBig32(data, 24) / (1 << 16))\n              data = data.subarray(28)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.esds = MP4Parser.esds(MP4Parser.findBox(data, ['esds'], start)[0])\n            })\n          case 'encv':\n            // sinf->schi->tenc\n            return parseBox(b, false, (ret, data, start) => {\n              ret.width = readBig16(data, 24)\n              ret.height = readBig16(data, 26)\n              ret.horizresolution = readBig32(data, 28)\n              ret.vertresolution = readBig32(data, 32)\n              data = data.subarray(78)\n              ret.sinf = MP4Parser.sinf(MP4Parser.findBox(data, ['sinf'], start)[0])\n              ret.avcC = MP4Parser.avcC(MP4Parser.findBox(data, ['avcC'], start)[0])\n              ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(data, ['hvcC'], start)[0])\n              ret.pasp = MP4Parser.pasp(MP4Parser.findBox(data, ['pasp'], start)[0])\n            })\n          default:\n        }\n      }).filter(Boolean)\n    })\n  }\n\n  static tenc (box) {\n    return parseBox(box, false, (ret, data) => {\n      let start = 6\n      ret.default_IsEncrypted = data[start]\n      start += 1\n      ret.default_IV_size = data[start]\n      start += 1\n      ret.default_KID = []\n      for (let i = 0; i < 16; i++) {\n        ret.default_KID.push(toHex(data[start]))\n        start += 1\n      }\n    })\n  }\n\n  static schi (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tenc = MP4Parser.tenc(MP4Parser.findBox(data, ['tenc'], start)[0])\n    })\n  }\n\n  static sinf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.schi = MP4Parser.schi(MP4Parser.findBox(data, ['schi'], start)[0])\n      ret.frma = MP4Parser.frma(MP4Parser.findBox(data, ['frma'], start)[0])\n    })\n  }\n\n  static frma (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data_format = ''\n      for (let i = 0; i < 4; i++) {\n        ret.data_format += String.fromCharCode(data[i])\n      }\n    })\n  }\n\n  static avc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.avcC = MP4Parser.avcC(MP4Parser.findBox(bodyData, ['avcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static avcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.configurationVersion = data[0]\n      ret.AVCProfileIndication = data[1]\n      ret.profileCompatibility = data[2]\n      ret.AVCLevelIndication = data[3]\n      ret.codec = getAvcCodec([data[1], data[2], data[3]])\n      ret.lengthSizeMinusOne = data[4] & 0x3\n      ret.spsLength = data[5] & 0x1F\n      ret.sps = []\n      let start = 6\n      for (let i = 0; i < ret.spsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.sps.push(data.subarray(start, start + size))\n        // ret.spsInfo = SpsParser.parseSPS(ret.sps[i])\n        // ret.pixelRatio = ret.spsInfo.par_ratio\n        start += size\n      }\n      ret.ppsLength = data[start]\n      start += 1\n      ret.pps = []\n      for (let i = 0; i < ret.ppsLength; i++) {\n        const size = readBig16(data, start)\n        start += 2\n        ret.pps.push(data.subarray(start, start += size))\n        start += size\n      }\n    })\n  }\n\n  static hvc1 (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseVisualSampleEntry(ret, data)\n      const bodyData = data.subarray(bodyStart)\n      start += bodyStart\n      ret.hvcC = MP4Parser.hvcC(MP4Parser.findBox(bodyData, ['hvcC'], start)[0])\n      ret.pasp = MP4Parser.pasp(MP4Parser.findBox(bodyData, ['pasp'], start)[0])\n    })\n  }\n\n  static hvcC (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.data = box.data\n      ret.codec = 'hev1.1.6.L93.B0'\n      ret.configurationVersion = data[0]\n      const tmp = data[1]\n      ret.generalProfileSpace = tmp >> 6\n      ret.generalTierFlag = (tmp & 0x20) >> 5\n      ret.generalProfileIdc = tmp & 0x1F\n      ret.generalProfileCompatibility = readBig32(data, 2)\n      ret.generalConstraintIndicatorFlags = data.subarray(6, 12)\n      ret.generalLevelIdc = data[12]\n      ret.avgFrameRate = readBig16(data, 19)\n      ret.numOfArrays = data[22]\n      ret.vps = []\n      ret.sps = []\n      ret.pps = []\n      let start = 23\n      let type = 0\n      let numNalus = 0\n      let size = 0\n      for (let i = 0; i < ret.numOfArrays; i++) {\n        type = data[start] & 0x3F\n        numNalus = readBig16(data, start + 1)\n        start += 3\n        const nalus = []\n        for (let j = 0; j < numNalus; j++) {\n          size = readBig16(data, start)\n          start += 2\n          nalus.push(data.subarray(start, start + size))\n          start += size\n        }\n\n        if (type === 32) {\n          ret.vps.push(...nalus)\n        } else if (type === 33) {\n          ret.sps.push(...nalus)\n        } else if (type === 34) {\n          ret.pps.push(...nalus)\n        }\n      }\n    })\n  }\n\n  static pasp (box) {\n    return parseBox(box, false, (ret, data) => {\n      ret.hSpacing = readBig32(data)\n      ret.vSpacing = readBig32(data, 4)\n    })\n  }\n\n  static mp4a (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      const bodyStart = parseAudioSampleEntry(ret, data)\n      ret.esds = MP4Parser.esds(MP4Parser.findBox(data.subarray(bodyStart), ['esds'], start + bodyStart)[0])\n    })\n  }\n\n  static esds (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.codec = 'mp4a.'\n      let start = 0\n      let byteRead = 0\n      let size = 0\n      let tag = 0\n      while (data.length) {\n        start = 0\n        tag = data[start]\n        byteRead = data[start + 1]\n        start += 2\n        while (byteRead & 0x80) {\n          size = (byteRead & 0x7F) << 7\n          byteRead = data[start]\n          start += 1\n        }\n        size += byteRead & 0x7F\n        if (tag === 3) {\n          data = data.subarray(start + 3)\n        } else if (tag === 4) {\n          ret.codec += (data[start].toString(16) + '.').padStart(3, '0')\n          data = data.subarray(start + 13)\n        } else if (tag === 5) {\n          const config = ret.config = data.subarray(start, start + size)\n          let objectType = (config[0] & 0xF8) >> 3\n          if (objectType === 31 && config.length >= 2) {\n            objectType = 32 + ((config[0] & 0x7) << 3) + ((config[1] & 0xE0) >> 5)\n          }\n          ret.objectType = objectType\n          ret.codec += objectType.toString(16)\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        } else {\n          if (ret.codec[ret.codec.length - 1] === '.') {\n            ret.codec = ret.codec.substring(0, ret.codec.length - 1)\n          }\n          return\n        }\n      }\n    })\n  }\n\n  static alaw (box) {\n    return parseBox(box, false, (ret, data) => {\n      parseAudioSampleEntry(ret, data)\n    })\n  }\n\n  static stts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          count: readBig32(data, start),\n          delta: readBig32(data, start + 4)\n        })\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static ctts (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      if (ret.version === 1) {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: readBig32(data, start + 4)\n          })\n          start += 8\n        }\n      } else {\n        for (let i = 0; i < entryCount; i++) {\n          entries.push({\n            count: readBig32(data, start),\n            offset: -(~readBig32(data, start + 4) + 1)\n          })\n          start += 8\n        }\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsc (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push({\n          firstChunk: readBig32(data, start),\n          samplesPerChunk: readBig32(data, start + 4),\n          sampleDescriptionIndex: readBig32(data, start + 8)\n        })\n        start += 12\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stsz (box) {\n    return parseBox(box, true, (ret, data) => {\n      const sampleSize = readBig32(data)\n      const sampleCount = readBig32(data, 4)\n      const entrySizes = []\n      if (!sampleSize) {\n        let start = 8\n        for (let i = 0; i < sampleCount; i++) {\n          entrySizes.push(readBig32(data, start))\n          start += 4\n        }\n      }\n      ret.sampleSize = sampleSize\n      ret.sampleCount = sampleCount\n      ret.entrySizes = entrySizes\n    })\n  }\n\n  static stco (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static co64 (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig64(data, start))\n        start += 8\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static stss (box) {\n    return parseBox(box, true, (ret, data) => {\n      const entryCount = readBig32(data)\n      const entries = []\n      let start = 4\n      for (let i = 0; i < entryCount; i++) {\n        entries.push(readBig32(data, start))\n        start += 4\n      }\n      ret.entryCount = entryCount\n      ret.entries = entries\n    })\n  }\n\n  static moof (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.mfhd = MP4Parser.mfhd(MP4Parser.findBox(data, ['mfhd'], start)[0])\n      ret.traf = MP4Parser.findBox(data, ['traf'], start).map(t => MP4Parser.traf(t))\n    })\n  }\n\n  static mfhd (box) {\n    return parseBox(box, true, (ret, data) => {\n      ret.sequenceNumber = readBig32(data)\n    })\n  }\n\n  static traf (box) {\n    return parseBox(box, false, (ret, data, start) => {\n      ret.tfhd = MP4Parser.tfhd(MP4Parser.findBox(data, ['tfhd'], start)[0])\n      ret.tfdt = MP4Parser.tfdt(MP4Parser.findBox(data, ['tfdt'], start)[0])\n      ret.trun = MP4Parser.trun(MP4Parser.findBox(data, ['trun'], start)[0])\n    })\n  }\n\n  static trun (box) {\n    return parseBox(box, true, (ret, data) => {\n      const { version, flags } = ret\n      const dataLen = data.length\n      const sampleCount = ret.sampleCount = readBig32(data)\n      let offset = 4\n      if (dataLen > offset && flags & 1) {\n        ret.dataOffset = -(~readBig32(data, offset) + 1)\n        offset += 4\n      }\n      if (dataLen > offset && flags & 4) {\n        ret.firstSampleFlags = readBig32(data, offset)\n        offset += 4\n      }\n      ret.samples = []\n      if (dataLen > offset) {\n        let sample\n        for (let i = 0; i < sampleCount; i++) {\n          sample = {}\n          if (flags & 0x100) {\n            sample.duration = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x200) {\n            sample.size = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x400) {\n            sample.flags = readBig32(data, offset)\n            offset += 4\n          }\n          if (flags & 0x800) {\n            if (version) {\n              sample.cts = -(~readBig32(data, offset + 4) + 1)\n            } else {\n              sample.cts = readBig32(data, offset)\n            }\n            offset += 4\n          }\n          ret.samples.push(sample)\n        }\n      }\n    })\n  }\n\n  static tfdt (box) {\n    return parseBox(box, true, (ret, data) => {\n      if (ret.version === 1) {\n        ret.baseMediaDecodeTime = readBig64(data)\n      } else {\n        ret.baseMediaDecodeTime = readBig32(data)\n      }\n    })\n  }\n\n  static probe (data) {\n    return !!MP4Parser.findBox(data, ['ftyp'])\n  }\n\n  static parseSampleFlags (flags) {\n    return {\n      isLeading: (flags[0] & 0x0c) >>> 2,\n      dependsOn: flags[0] & 0x03,\n      isDependedOn: (flags[1] & 0xc0) >>> 6,\n      hasRedundancy: (flags[1] & 0x30) >>> 4,\n      paddingValue: (flags[1] & 0x0e) >>> 1,\n      isNonSyncSample: flags[1] & 0x01,\n      degradationPriority: (flags[2] << 8) | flags[3]\n    }\n  }\n\n  static moovToTrack (moov, videoTrack, audioTrack) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (vTrack && videoTrack) {\n      const v = videoTrack\n      const _vTrackId = vTrack.tkhd?.trackId\n      if (_vTrackId !== null && _vTrackId !== undefined) v.id = vTrack.tkhd.trackId\n      v.tkhdDuration = vTrack.tkhd.duration\n      v.mvhdDurtion = moov.mvhd.duration\n      v.mvhdTimecale = moov.mvhd.timescale\n      v.timescale = v.formatTimescale = vTrack.mdia.mdhd.timescale\n      v.duration = vTrack.mdia.mdhd.duration || (v.mvhdDurtion / v.mvhdTimecale * v.timescale)\n      const e1 = vTrack.mdia.minf.stbl.stsd.entries[0]\n      v.width = e1.width\n      v.height = e1.height\n      if (e1.pasp) {\n        v.sarRatio = [e1.pasp.hSpacing, e1.pasp.vSpacing]\n      }\n      if (e1.hvcC) {\n        v.codecType = VideoCodecType.HEVC\n        v.codec = e1.hvcC.codec\n        v.vps = e1.hvcC.vps\n        v.sps = e1.hvcC.sps\n        v.pps = e1.hvcC.pps\n        v.hvcC = e1.hvcC.data\n      } else if (e1.avcC) {\n        v.codec = e1.avcC.codec\n        v.sps = e1.avcC.sps\n        v.pps = e1.avcC.pps\n      } else {\n        throw new Error('unknown video stsd entry')\n      }\n      v.present = true\n      v.ext = {}\n      v.ext.stss = vTrack.mdia?.minf?.stbl?.stss\n      v.ext.ctts = vTrack.mdia?.minf?.stbl?.ctts\n\n      if (e1 && e1.type === 'encv') {\n        v.isVideoEncryption = true\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        v.videoSenc = vTrack.mdia.minf.stbl.senc && vTrack.mdia.minf.stbl.senc.samples\n        e1.data_format = e1.sinf?.frma?.data_format\n        v.useEME = moov.useEME\n        v.kidValue = moov.kidValue\n        v.pssh = moov.pssh\n        v.encv = e1\n      }\n    }\n\n    if (aTrack && audioTrack) {\n      const a = audioTrack\n      const _aTrackId = aTrack.tkhd?.trackId\n      if (_aTrackId !== null && _aTrackId !== undefined) a.id = aTrack.tkhd.trackId\n      a.tkhdDuration = aTrack.tkhd.duration\n      a.mvhdDurtion = moov.mvhd.duration\n      a.mvhdTimecale = moov.mvhd.timescale\n      a.timescale = a.formatTimescale = aTrack.mdia.mdhd.timescale\n      a.duration = aTrack.mdia.mdhd.duration || (a.mvhdDurtion / a.mvhdTimecale * a.timescale)\n      const e1 = aTrack.mdia.minf.stbl.stsd.entries[0]\n      a.sampleSize = e1.sampleSize\n      a.sampleRate = e1.sampleRate\n      a.channelCount = e1.channelCount\n      a.present = true\n\n      switch (e1.type) {\n        case 'alaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMA\n          a.sampleRate = 8000\n          break\n        case 'ulaw':\n          a.codecType = a.codec = AudioCodecType.G711PCMU\n          a.sampleRate = 8000\n          break\n        default:\n          a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n          a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n          a.objectType = e1.esds?.objectType || 2\n          if (e1.esds) a.config = Array.from(e1.esds.config)\n          a.codec = e1.esds?.codec || 'mp4a.40.2'\n          break\n      }\n      a.sampleDuration = AAC.getFrameDuration(a.sampleRate, a.timescale)\n      a.objectType = e1.esds?.objectType || 2\n      if (e1.esds) {\n        if (e1.esds.config) {\n          a.config = Array.from(e1.esds.config)\n        } else {\n          console.warn('esds config is null')\n        }\n      }\n      a.codec = e1.esds?.codec || 'mp4a.40.2'\n      a.sampleRateIndex = AAC.getRateIndexByRate(a.sampleRate)\n      a.ext = {}\n      a.ext.stss = aTrack.mdia?.minf?.stbl?.stss\n      a.ext.ctts = aTrack.mdia?.minf?.stbl?.ctts\n      a.present = true\n      if (e1 && e1.type === 'enca') {\n        a.isAudioEncryption = true\n        e1.data_format = e1.sinf?.frma?.data_format\n        e1.default_KID = e1.sinf?.schi?.tenc.default_KID\n        e1.default_IsEncrypted = e1.sinf?.schi?.tenc.default_IsEncrypted\n        e1.default_IV_size = e1.sinf?.schi?.tenc.default_IV_size\n        a.audioSenc = aTrack.mdia.minf.stbl.senc && aTrack.mdia.minf.stbl.senc.samples\n        a.useEME = moov.useEME\n        a.kidValue = moov.kidValue\n        a.enca = e1\n      }\n    }\n\n    audioTrack && (audioTrack.isVideoEncryption = videoTrack ? videoTrack.isVideoEncryption : false)\n    videoTrack && (videoTrack.isAudioEncryption = audioTrack ? audioTrack.isAudioEncryption : false)\n\n    if (videoTrack?.encv || audioTrack?.enca) {\n      const vkid = videoTrack?.encv?.default_KID\n      const akid = audioTrack?.enca?.default_KID\n      const kid = (vkid || akid) ? (vkid || akid).join('') : null\n      videoTrack && (videoTrack.kid = kid)\n      audioTrack && (audioTrack.kid = kid)\n    }\n\n    videoTrack && (videoTrack.flags = 0xf01)\n    audioTrack && (audioTrack.flags = 0x701)\n\n    return {\n      videoTrack,\n      audioTrack\n    }\n  }\n\n  static evaluateDefaultDuration (videoTrack, audioTrack, videoSampleCount) {\n    const audioSampleCount = audioTrack?.samples?.length\n\n    // audio\n    if (!audioSampleCount) return 1024\n\n    const segmentDuration = 1024 * audioSampleCount / audioTrack.timescale\n\n    return segmentDuration * videoTrack.timescale / videoSampleCount\n  }\n\n  static moofToSamples (moof, videoTrack, audioTrack) {\n    const ret = {}\n\n    if (moof.mfhd) {\n      if (videoTrack) videoTrack.sequenceNumber = moof.mfhd.sequenceNumber\n      if (audioTrack) audioTrack.sequenceNumber = moof.mfhd.sequenceNumber\n    }\n\n    moof.traf.forEach(({ tfhd, tfdt, trun }) => {\n      if (!tfhd || !trun) return\n      if (tfdt) {\n        if (videoTrack && videoTrack.id === tfhd.trackId) videoTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n        if (audioTrack && audioTrack.id === tfhd.trackId) audioTrack.baseMediaDecodeTime = tfdt.baseMediaDecodeTime\n      }\n      const defaultSize = tfhd.defaultSampleSize || 0\n      const defaultDuration = tfhd.defaultSampleDuration || MP4Parser.evaluateDefaultDuration(videoTrack, audioTrack, trun.samples.length || trun.sampleCount)\n      let offset = trun.dataOffset || 0\n      let dts = 0\n      let gopId = -1\n      if (!trun.samples.length && trun.sampleCount) {\n        ret[tfhd.trackId] = []\n        for (let i = 0; i < trun.sampleCount; i++) {\n          ret[tfhd.trackId].push({\n            offset,\n            dts,\n            duration: defaultDuration,\n            size: defaultSize\n          })\n          dts += defaultDuration\n          offset += defaultSize\n        }\n      } else {\n        ret[tfhd.trackId] = trun.samples.map((s, index) => {\n          s = {\n            offset,\n            dts,\n            pts: dts + (s.cts || 0),\n            duration: s.duration || defaultDuration,\n            size: s.size || defaultSize,\n            gopId,\n            keyframe: index === 0 || ((s.flags !== null && s.flags !== undefined) && ((s.flags & 65536) >>> 0) !== 65536)\n          }\n          if (s.keyframe) {\n            gopId++\n            s.gopId = gopId\n          }\n          dts += s.duration\n          offset += s.size\n          return s\n        })\n      }\n    })\n\n    return ret\n  }\n\n  static moovToSamples (moov) {\n    const tracks = moov.trak\n    if (!tracks || !tracks.length) return\n    const vTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'vide')\n    const aTrack = tracks.find(t => t.mdia?.hdlr?.handlerType === 'soun')\n    if (!vTrack && !aTrack) return\n    let videoSamples\n    let audioSamples\n    if (vTrack) {\n      const videoStbl = vTrack.mdia?.minf?.stbl\n      if (!videoStbl) return\n      const { stts, stsc, stsz, stco, stss, ctts } = videoStbl\n      if (!stts || !stsc || !stsz || !stco || !stss) return\n      videoSamples = getSamples(stts, stsc, stsz, stco, ctts, stss)\n    }\n    if (aTrack) {\n      const audioStbl = aTrack.mdia?.minf?.stbl\n      if (!audioStbl) return\n      const timescale = aTrack.mdia.mdhd?.timescale\n      const { stts, stsc, stsz, stco } = audioStbl\n      if (!timescale || !stts || !stsc || !stsz || !stco) return\n      audioSamples = getSamples(stts, stsc, stsz, stco)\n    }\n\n    return {\n      videoSamples,\n      audioSamples\n    }\n  }\n}\n\nfunction getSamples (stts, stsc, stsz, stco, ctts, stss) {\n  const samples = []\n  const cttsEntries = ctts?.entries\n  const stscEntries = stsc.entries\n  const stcoEntries = stco.entries\n  const stszEntrySizes = stsz.entrySizes\n  const stssEntries = stss?.entries\n  let keyframeMap\n  if (stssEntries) {\n    keyframeMap = {}\n    stssEntries.forEach(x => { keyframeMap[x - 1] = true })\n  }\n  let cttsArr\n  if (cttsEntries) {\n    cttsArr = []\n    cttsEntries.forEach(({ count, offset }) => {\n      for (let i = 0; i < count; i++) {\n        cttsArr.push(offset)\n      }\n    })\n  }\n\n  let sample\n  let gopId = -1\n  let dts = 0\n  let pos = 0\n  let chunkIndex = 0\n  let chunkRunIndex = 0\n  let offsetInChunk = 0\n  let lastSampleInChunk = stscEntries[0].samplesPerChunk\n  let lastChunkInRun = stscEntries[1] ? stscEntries[1].firstChunk - 1 : Infinity\n  stts.entries.forEach(({ count, delta }) => {\n    for (let i = 0; i < count; i++) {\n      sample = {\n        dts,\n        duration: delta,\n        size: stszEntrySizes[pos] || stsz.sampleSize,\n        offset: stcoEntries[chunkIndex] + offsetInChunk,\n        index: pos\n      }\n      if (stssEntries) {\n        sample.keyframe = keyframeMap[pos]\n        if (sample.keyframe) {\n          gopId++\n        }\n        sample.gopId = gopId\n      }\n      // sample.timeOffset = 0\n      if (cttsArr && pos < cttsArr.length) {\n        sample.pts = sample.dts + cttsArr[pos]\n        // sample.timeOffset = cttsArr[pos]\n        // if (pos === 0) {\n        //   sample.pts = sample.dts\n        //   sample.timeOffset = 0\n        // }\n      }\n      samples.push(sample)\n      dts += delta\n      pos++\n\n      if (pos < lastSampleInChunk) {\n        offsetInChunk += sample.size\n      } else {\n        chunkIndex++\n        offsetInChunk = 0\n        if (chunkIndex >= lastChunkInRun) {\n          chunkRunIndex++\n          lastChunkInRun = stscEntries[chunkRunIndex + 1] ? stscEntries[chunkRunIndex + 1].firstChunk - 1 : Infinity\n        }\n        lastSampleInChunk += stscEntries[chunkRunIndex].samplesPerChunk\n      }\n    }\n  })\n\n  return samples\n}\n\nfunction parseVisualSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.width = readBig16(data, 24)\n  ret.height = readBig16(data, 26)\n  ret.horizresolution = readBig32(data, 28)\n  ret.vertresolution = readBig32(data, 32)\n  ret.frameCount = readBig16(data, 40)\n  ret.depth = readBig16(data, 74)\n  return 78\n}\n\nfunction parseAudioSampleEntry (ret, data) {\n  ret.dataReferenceIndex = readBig16(data, 6)\n  ret.channelCount = readBig16(data, 16)\n  ret.sampleSize = readBig16(data, 18)\n  ret.sampleRate = readBig32(data, 24) / (1 << 16)\n  return 28\n}\n\nfunction parseBox (box, isFullBox, parse) {\n  if (!box) return\n  if (box.size !== box.data.length) throw new Error(`box ${box.type} size !== data.length`)\n  const ret = {\n    start: box.start,\n    size: box.size,\n    headerSize: box.headerSize,\n    type: box.type\n  }\n  if (isFullBox) {\n    ret.version = box.data[box.headerSize]\n    ret.flags = readBig24(box.data, box.headerSize + 1)\n    ret.headerSize += 4\n  }\n  parse(ret, box.data.subarray(ret.headerSize), ret.start + ret.headerSize)\n  return ret\n}\n\nconst padStart = function (str, length, pad) {\n  const charstr = String(pad)\n  const len = length >> 0\n  let maxlen = Math.ceil(len / charstr.length)\n  const chars = []\n  const r = String(str)\n  while (maxlen--) {\n    chars.push(charstr)\n  }\n  return chars.join('').substring(0, len - r.length) + r\n}\n\nconst toHex = function (...value) {\n  const hex = []\n  value.forEach(item => {\n    hex.push(padStart(Number(item).toString(16), 2, 0))\n  })\n  return hex[0]\n}\n","import { VideoTrack, AudioTrack, MetadataTrack, VideoSample, AudioSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\n\nexport class FMP4Demuxer {\n  constructor (videoTrack, audioTrack, metadataTrack) {\n    this.videoTrack = videoTrack || new VideoTrack()\n    this.audioTrack = audioTrack || new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n  }\n\n  demux (videoData, audioData) {\n    const { videoTrack, audioTrack } = this\n    const videoExist = videoTrack.exist()\n    const audioExist = audioTrack.exist()\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    if (audioData) {\n      if (!audioExist) {\n        const moovBox = MP4Parser.findBox(audioData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), null, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(audioData, ['moof'])[0]\n      if (moofBox) {\n        const samples = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), null, audioTrack)[audioTrack.id]\n        const baseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        if (samples) {\n          const baseOffset = moofBox.start\n          samples.map(x => {\n            x.offset += baseOffset\n            const sampleData = audioData.subarray(x.offset, x.offset + x.size)\n            audioTrack.samples.push(new AudioSample(x.dts + baseMediaDecodeTime, sampleData, x.duration))\n          })\n        }\n      }\n    }\n\n    if (videoData) {\n      if (!videoExist && !audioExist) {\n        const moovBox = MP4Parser.findBox(videoData, ['moov'])[0]\n        if (!moovBox) throw new Error('cannot found moov box')\n        MP4Parser.moovToTrack(MP4Parser.moov(moovBox), videoTrack, audioTrack)\n      }\n      const moofBox = MP4Parser.findBox(videoData, ['moof'])[0]\n      if (moofBox) {\n        const tracks = MP4Parser.moofToSamples(MP4Parser.moof(moofBox), videoTrack, audioTrack)\n        const videoBaseMediaDecodeTime = videoTrack.baseMediaDecodeTime\n        const audioBaseMediaDecodeTime = audioTrack.baseMediaDecodeTime\n        const baseOffset = moofBox.start\n        let nalSize\n        Object.keys(tracks).forEach(k => {\n          // eslint-disable-next-line eqeqeq\n          if (videoTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sample = new VideoSample((x.pts || x.dts) + videoBaseMediaDecodeTime, x.dts + videoBaseMediaDecodeTime)\n              sample.duration = x.duration\n              sample.gopId = x.gopId\n              if (x.keyframe) sample.setToKeyframe()\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              sample.data = sampleData\n              let start = 0\n              const len = sampleData.length - 1\n              while (start < len) {\n                nalSize = readBig32(sampleData, start)\n                start += 4\n                sample.units.push(sampleData.subarray(start, start + nalSize))\n                start += nalSize\n              }\n              videoTrack.samples.push(sample)\n            })\n            // eslint-disable-next-line eqeqeq\n          } else if (audioTrack.id == k) {\n            tracks[k].map(x => {\n              x.offset += baseOffset\n              const sampleData = videoData.subarray(x.offset, x.offset + x.size)\n              audioTrack.samples.push(new AudioSample(x.dts + audioBaseMediaDecodeTime, sampleData, x.duration))\n            })\n          }\n        })\n      }\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","\n// 改造为兼容IE11\nfunction Concat (ResultConstructor, ...arrays){\n  let totalLength = 0\n  arrays.forEach(function (arr){\n    totalLength += arr.length\n  })\n  const result = new ResultConstructor(totalLength)\n  let offset = 0\n  arrays.forEach(function (arr){\n    result.set(arr, offset)\n    offset += arr.length\n  })\n  return result\n}\n\nclass Buffer {\n  constructor () {\n    this.buffer = new Uint8Array(0)\n  }\n\n  write (...buffer) {\n    const self = this\n    buffer.forEach(item => {\n      if (item) {\n        self.buffer = Concat(Uint8Array, self.buffer, item)\n      } else {\n        window.console.warn(item)\n      }\n    })\n  }\n\n  static writeUint16 (value) {\n    return new Uint8Array([\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n\n  static writeUint32 (value) {\n    return new Uint8Array([\n      value >> 24,\n      (value >> 16) & 0xff,\n      (value >> 8) & 0xff,\n      value & 0xff\n    ])\n  }\n}\n\nexport default Buffer\n","import { TrackType, VideoCodecType } from '../model'\nimport { concatUint8Array, parse /* hashVal */ } from '../utils'\nimport Buffer from './buffer'\n// import Crypto from './crypto/crypto'\nconst UINT32_MAX = 2 ** 32 - 1\n\nexport class MP4 {\n  static types = [\n    'avc1',\n    'avcC',\n    'hvc1',\n    'hvcC',\n    'dinf',\n    'dref',\n    'esds',\n    'ftyp',\n    'hdlr',\n    'mdat',\n    'mdhd',\n    'mdia',\n    'mfhd',\n    'minf',\n    'moof',\n    'moov',\n    'mp4a',\n    'mvex',\n    'mvhd',\n    'pasp',\n    'stbl',\n    'stco',\n    'stsc',\n    'stsd',\n    'stsz',\n    'stts',\n    'tfdt',\n    'tfhd',\n    'traf',\n    'trak',\n    'trex',\n    'tkhd',\n    'vmhd',\n    'smhd',\n    'ctts',\n    'stss',\n    'styp',\n    'pssh',\n    'sidx',\n    'sbgp',\n    'saiz',\n    'saio',\n    'senc',\n    'trun',\n    'encv',\n    'enca',\n    'sinf',\n    'btrt',\n    'frma',\n    'tenc',\n    'schm',\n    'schi',\n    'mehd',\n    'fiel',\n    'sdtp'\n  ].reduce((p, c) => {\n    p[c] = [c.charCodeAt(0), c.charCodeAt(1), c.charCodeAt(2), c.charCodeAt(3)]\n    return p\n  }, Object.create(null));\n\n  static HDLR_TYPES = {\n    video: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x76, 0x69, 0x64, 0x65, // handler_type: 'vide'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x56, 0x69, 0x64, 0x65, 0x6f, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'VideoHandler'\n    ]),\n    audio: new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0x73, 0x6f, 0x75, 0x6e, // handler_type: 'soun'\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x53, 0x6f, 0x75, 0x6e, 0x64, 0x48, 0x61,\n      0x6e, 0x64, 0x6c, 0x65, 0x72, 0x00 // name: 'SoundHandler'\n    ])\n  }\n\n  static FTYPAVC1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    97, 118, 99, 49 // avc1\n  ]))\n\n  static FTYPHEV1 = MP4.box(MP4.types.ftyp, new Uint8Array([\n    105, 115, 111, 109, // isom\n    0, 0, 0, 1,\n    105, 115, 111, 109,\n    104, 101, 118, 49 // hev1\n  ]))\n\n  static DINF = MP4.box(MP4.types.dinf, MP4.box(MP4.types.dref, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x01, // entry_count\n    0x00, 0x00, 0x00, 0x0c, // entry_size\n    0x75, 0x72, 0x6c, 0x20, // 'url' type\n    0x00, // version\n    0x00, 0x00, 0x01 // entry_flags\n  ])))\n\n  static VMHD = MP4.box(MP4.types.vmhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x01, // flags\n    0x00, 0x00, // graphics mode\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00 // op color\n  ]))\n\n  static SMHD = MP4.box(MP4.types.smhd, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, // balance\n    0x00, 0x00 // reserved\n  ]))\n\n  static StblTable = new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00 // entry_count\n  ])\n\n  static STTS = MP4.box(MP4.types.stts, MP4.StblTable)\n\n  static STSC = MP4.box(MP4.types.stsc, MP4.StblTable)\n\n  static STSZ = MP4.box(MP4.types.stsz, new Uint8Array([\n    0x00, // version\n    0x00, 0x00, 0x00, // flags\n    0x00, 0x00, 0x00, 0x00, // sample_size\n    0x00, 0x00, 0x00, 0x00 // sample_count\n  ]))\n\n  static STCO = MP4.box(MP4.types.stco, MP4.StblTable)\n\n  static box (type, ...payload) {\n    payload = payload.filter(Boolean)\n    const size = 8 + payload.reduce((p, c) => (p + c.byteLength), 0)\n    const ret = new Uint8Array(size)\n    ret[0] = (size >> 24) & 0xff\n    ret[1] = (size >> 16) & 0xff\n    ret[2] = (size >> 8) & 0xff\n    ret[3] = size & 0xff\n    ret.set(type, 4)\n    let offset = 8\n    payload.forEach((data) => {\n      ret.set(data, offset)\n      offset += data.byteLength\n    })\n    return ret\n  }\n\n  static ftyp (tracks) {\n    const isHevc = tracks.find(t => t.type === TrackType.VIDEO && t.codecType === VideoCodecType.HEVC)\n    return isHevc ? MP4.FTYPHEV1 : MP4.FTYPAVC1\n  }\n\n  static initSegment (tracks) {\n    const ftyp = MP4.ftyp(tracks)\n    // console.log('[remux],ftyp ,len ', ftyp.byteLength, hashVal(ftyp.toString()))\n    const init = concatUint8Array(ftyp, MP4.moov(tracks))\n    // console.log('[remux],init ,len ', init.byteLength, hashVal(init.toString()))\n    return init\n  }\n\n  static pssh (data) {\n    // const buffer = new Buffer()\n    const content = new Uint8Array(\n      [\n        0x01, 0x00, 0x00, 0x00 // version\n      ].concat(\n        [\n          0x10, 0x77, 0xef, 0xec,\n          0xc0, 0xb2, 0x4d, 0x02,\n          0xac, 0xe3, 0x3c, 0x1e,\n          0x52, 0xe2, 0xfb, 0x4b\n        ],\n        [0x00, 0x00, 0x00, 0x01],\n        parse(data.kid),\n        [0x00, 0x00, 0x00, 0x00]\n      )\n    )\n    return MP4.box(MP4.types.pssh, content)\n  }\n\n  static moov (tracks) {\n    if (tracks[0].useEME && (tracks[0].encv || tracks[0].enca)) {\n      if (!tracks[0].pssh) {\n        tracks[0].pssh = {\n          kid: tracks[0].kid\n        }\n      }\n      const pssh = this.pssh(tracks[0].pssh)\n      // console.log('[remux],pssh,', hashVal(pssh.toString()))\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        MP4.mvex(tracks),\n        ...tracks.map((t) => MP4.trak(t)),\n        pssh)\n    } else {\n      return MP4.box(MP4.types.moov,\n        MP4.mvhd(tracks[0].mvhdDurtion || tracks[0].duration, tracks[0].mvhdTimecale || tracks[0].timescale),\n        ...tracks.map((t) => MP4.trak(t)),\n        MP4.mvex(tracks)\n      )\n    }\n  }\n\n  static mvhd (duration, timescale = 90000) {\n    const mvhd = MP4.box(MP4.types.mvhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x01, 0x00, 0x00, // rate\n      0x01, 0x00, // volume\n      0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      0xff, 0xff, 0xff, 0xff // todo 0xff, 0xff, 0xff, 0xff // next_track_ID\n    ]))\n    // console.log('[remux],mvhd, len,', mvhd.byteLength, hashVal(mvhd.toString()))\n    return mvhd\n  }\n\n  static trak (track) {\n    const trak = MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.tkhdDuration || 0, track.width, track.height),\n      MP4.mdia(track)\n    )\n    // console.log('[remux],trak, len,', trak.byteLength, track.id, hashVal(trak.toString()))\n    return trak\n  }\n\n  static tkhd (id, duration, width = 0, height = 0) {\n    const tkhd = MP4.box(MP4.types.tkhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x07, // flags、todo 0x07\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // modification_time todo\n      (id >> 24) & 0xff, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff,\n      0x00, 0x00, 0x00, 0x00,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // todo (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, // layer\n      0x00, 0x00, // /*0x00*/ alternate_group  //todo type === 'video' ? 0x01 : 0x00（第二个位置）\n      0x01, 0x00, // /* 0x01 */, 0x00, // non-audio track volume  //todo type === 'audio' ? 0x01 : 0x00（第一个位置）\n      0x00, 0x00, // reserved\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x01, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x40, 0x00, 0x00, 0x00, // matrix\n      (width >> 8) & 0xff, width & 0xff, 0x00, 0x00,\n      (height >> 8) & 0xff, height & 0xff, 0x00, 0x00\n    ]))\n    // console.log('[remux],tkhd, len,', tkhd.byteLength, hashVal(tkhd.toString()))\n    return tkhd\n  }\n\n  static mdia (track) {\n    const mdia = MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minf(track))\n    // console.log('[remux],mdia, len,', mdia.byteLength, hashVal(mdia.toString()))\n    return mdia\n  }\n\n  static mdhd (duration, timescale = 90000) {\n    const mdhd = MP4.box(MP4.types.mdhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x00, // creation_time\n      0x00, 0x00, 0x00, 0x00, // todo 0x00, 0x00, 0x00, 0x00, // modification_time\n      (timescale >> 24) & 0xff, (timescale >> 16) & 0xff, (timescale >> 8) & 0xff, timescale & 0xff,\n      (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff, // (duration >> 24) & 0xff, (duration >> 16) & 0xff, (duration >> 8) & 0xff, duration & 0xff,//todo\n      0x55, 0xc4, // 'und' language (undetermined) //todo 0x15, 0xC7\n      0x00, 0x00 // pre_defined\n    ]))\n    // console.log('[remux],mdhd, len,', mdhd.byteLength, hashVal(mdhd.toString()))\n    return mdhd\n  }\n\n  static hdlr (type) {\n    const hdlr = MP4.box(MP4.types.hdlr, MP4.HDLR_TYPES[type])\n    // console.log('[remux],hdlr, len,', hdlr.byteLength, hashVal(hdlr.toString()))\n    return hdlr\n  }\n\n  static minf (track) {\n    const minf = MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stbl(track))\n    // console.log('[remux],minf, len,', minf.byteLength, hashVal(minf.toString()))\n    return minf\n  }\n\n  static stbl (track) {\n    const extBox = []\n    if (track && track.ext) {\n      track.ext.stss && extBox.push(MP4.stss(track.ext.stss.entries))\n      // track.ext.stss && extBox.push(MP4.ctts(track.ext.stss.entries))\n    }\n    const stbl = MP4.box(MP4.types.stbl, MP4.stsd(track), MP4.STTS, extBox[0], MP4.STSC, MP4.STSZ, MP4.STCO)\n    // console.log('[remux],stbl, len,', stbl.byteLength, hashVal(stbl.toString()))\n    return stbl\n  }\n\n  static stsd (track) {\n    let content\n    if (track.type === 'audio') {\n      if (track.useEME && track.enca) {\n        content = MP4.enca(track)\n        // console.log('[remux],enca, len,', content.byteLength, track.type, hashVal(content.toString()))\n      } else {\n        content = MP4.mp4a(track)\n        // console.log('[remux],mp4a, len,', content.byteLength, track.type, hashVal(content.toString()))\n      }\n    } else if (track.useEME && track.encv) {\n      content = MP4.encv(track)\n      // console.log('[remux],encv, len,', content.byteLength, track.type, hashVal(content.toString()))\n    } else {\n      content = MP4.avc1hev1(track)\n      // console.log('[remux],avc1hev1, len,', content.byteLength, track.type, hashVal(content.toString()))\n    }\n    const stsd = MP4.box(MP4.types.stsd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      0x00, 0x00, 0x00, 0x01 // entry_count\n    ]), content)\n    // console.log('[remux],stsd, len,', stsd.byteLength, hashVal(stsd.toString()))\n    return stsd\n  }\n\n  static enca (data) {\n    const channelCount = data.enca.channelCount\n    const sampleRate = data.enca.sampleRate\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, channelCount, // channelcount\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, 0x00, 0x00, // reserved2\n      (sampleRate >> 8) & 0xff,\n      sampleRate & 0xff, //\n      0x00, 0x00\n    ])\n    const esds = MP4.esds(data.config)\n    // console.log('[remux],esds, len,', esds.byteLength, hashVal(esds.toString()))\n    const sinf = MP4.sinf(data.enca)\n    // console.log('[remux],sinf, len,', sinf.byteLength, hashVal(sinf.toString()))\n    return MP4.box(MP4.types.enca, content, esds, sinf)\n  }\n\n  static encv (track) {\n    const sps = track.sps.length > 0 ? track.sps[0] : []\n    const pps = track.pps.length > 0 ? track.pps[0] : []\n    const width = track.width\n    const height = track.height\n    const hSpacing = track.sarRatio[0]\n    const vSpacing = track.sarRatio[1]\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00, // pre_defined\n      (width >> 8) & 0xff,\n      width & 0xff, // width\n      (height >> 8) & 0xff,\n      height & 0xff, // height\n      0x00, 0x48, 0x00, 0x00, // horizresolution\n      0x00, 0x48, 0x00, 0x00, // vertresolution\n      0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // frame_count\n\n      0x12,\n      0x64, 0x61, 0x69, 0x6C, // dailymotion/hls.js\n      0x79, 0x6D, 0x6F, 0x74,\n      0x69, 0x6F, 0x6E, 0x2F,\n      0x68, 0x6C, 0x73, 0x2E,\n      0x6A, 0x73, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // compressorname\n      0x00, 0x18, // depth = 24\n      0x11, 0x11]) // pre_defined = -1;\n    const avcc = new Uint8Array([\n      0x01, // version\n      sps[1], // profile\n      sps[2], // profile compatible\n      sps[3], // level\n      0xfc | 3,\n      0xE0 | 1, // 目前只处理一个sps\n      sps.length >>> 8 & 0xff,\n      sps.length & 0xff\n    ].concat(...sps).concat([\n      0x01,\n      pps.length >>> 8 & 0xff,\n      pps.length & 0xff\n    ]).concat(...pps))\n    const btrt = new Uint8Array([\n      0x00, 0x00, 0x58, 0x39,\n      0x00, 0x0F, 0xC8, 0xC0,\n      0x00, 0x04, 0x56, 0x48\n    ])\n    const sinf = MP4.sinf(track.encv)\n    const pasp = new Uint8Array([\n      (hSpacing >> 24), // hSpacing\n      (hSpacing >> 16) & 0xff,\n      (hSpacing >> 8) & 0xff,\n      hSpacing & 0xff,\n      (vSpacing >> 24), // vSpacing\n      (vSpacing >> 16) & 0xff,\n      (vSpacing >> 8) & 0xff,\n      vSpacing & 0xff\n    ])\n    return MP4.box(MP4.types.encv, content, MP4.box(MP4.types.avcC, avcc), MP4.box(MP4.types.btrt, btrt), sinf, MP4.box(MP4.types.pasp, pasp))\n  }\n\n  static schi (data) {\n    const content = new Uint8Array([])\n    const tenc = MP4.tenc(data)\n    return MP4.box(MP4.types.schi, content, tenc)\n  }\n\n  static tenc (data) {\n    //  用于每个track的加密参数（包括KID、初始化向量、加密标志位），包含在TrackEncryptionBox(‘tenc’)中。\n    const content = new Uint8Array(\n      [\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // skip\n        data.default_IsEncrypted & 0xff, // default_isProtected\n        data.default_IV_size & 0xff // default_Per_Sample_IV_Size\n      ].concat(parse(data.default_KID)))\n    return MP4.box(MP4.types.tenc, content)\n  }\n\n  static sinf (data) {\n    const content = new Uint8Array([])\n    const frma = new Uint8Array([\n      data.data_format.charCodeAt(0),\n      data.data_format.charCodeAt(1),\n      data.data_format.charCodeAt(2),\n      data.data_format.charCodeAt(3)\n    ])\n    const schm = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x63, 0x65, 0x6E, 0x63, // cenc\n      0x00, 0x01, 0x00, 0x00 // version\n    ])\n    const schi = MP4.schi(data)\n    return MP4.box(MP4.types.sinf, content, MP4.box(MP4.types.frma, frma), MP4.box(MP4.types.schm, schm), schi)\n  }\n\n  static avc1hev1 (track) {\n    const isHevc = track.codecType === VideoCodecType.HEVC\n    const typ = isHevc ? MP4.types.hvc1 : MP4.types.avc1\n    const config = isHevc ? MP4.hvcC(track) : MP4.avcC(track)\n    const boxes = [\n      new Uint8Array([\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // data_reference_index\n        0x00, 0x00, // pre_defined\n        0x00, 0x00, // reserved\n        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // pre_defined\n        (track.width >> 8) & 0xff, track.width & 0xff, // width\n        (track.height >> 8) & 0xff, track.height & 0xff, // height\n        0x00, 0x48, 0x00, 0x00, // horizresolution\n        0x00, 0x48, 0x00, 0x00, // vertresolution\n        0x00, 0x00, 0x00, 0x00, // reserved\n        0x00, 0x01, // frame_count\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00,\n        0x00, 0x00, 0x00, 0x00, // compressor name\n        0x00, 0x18, // depth\n        0x11, 0x11 // pre_defined = -1 //todo\n      ]), config\n    ]\n    // console.log('[remux],avc1hev1_0, len,', boxes[0].byteLength, hashVal(boxes[0].toString()))\n    // console.log('[remux],avc1hev1_1, len,', boxes[1].byteLength, hashVal(boxes[1].toString()))\n    if (isHevc) {\n      boxes.push(MP4.box(MP4.types.fiel, new Uint8Array([0x01, 0x00])))\n      // console.log('[remux],fiel, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    } else if (track.sarRatio && track.sarRatio.length > 1) {\n      boxes.push(MP4.pasp(track.sarRatio))\n      // console.log('[remux],pasp, len,', boxes[2].byteLength, hashVal(boxes[2].toString()))\n    }\n    return MP4.box(typ, ...boxes)\n  }\n\n  static avcC (track) {\n    const sps = []\n    const pps = []\n\n    let len\n    track.sps.forEach((s) => {\n      len = s.byteLength\n      sps.push((len >>> 8) & 0xff)\n      sps.push(len & 0xff)\n      sps.push(...s)\n    })\n\n    track.pps.forEach((p) => {\n      len = p.byteLength\n      pps.push((len >>> 8) & 0xff)\n      pps.push(len & 0xff)\n      pps.push(...p)\n    })\n\n    return MP4.box(MP4.types.avcC, new Uint8Array([\n      0x01, // configurationVersion\n      sps[3], // AVCProfileIndication\n      sps[4], // profile_compatibility\n      sps[5], // AVCLevelIndication\n      0xfc | 3, // lengthSizeMinusOne\n      0xe0 | track.sps.length // 3bit reserved (111) + numOfSequenceParameterSets\n    ].concat(...sps)\n      .concat([track.pps.length]) // numOfPictureParameterSets\n      .concat(...pps)))\n  }\n\n  static hvcC (track) {\n    const hvcC = track.hvcC\n    if (hvcC instanceof ArrayBuffer || hvcC instanceof Uint8Array) return hvcC\n    const { vps, sps, pps } = track\n    let data\n    if (hvcC) {\n      const pcf = hvcC.generalProfileCompatibilityFlags\n      const cif = hvcC.generalConstraintIndicatorFlags\n      const numOfArrays = (vps.length && 1) + (sps.length && 1) + (pps.length && 1)\n      data = [\n        0x01, // configurationVersion\n        hvcC.generalProfileSpace << 6 | hvcC.generalTierFlag << 5 | hvcC.generalProfileIdc,\n        pcf >>> 24, pcf >>> 16, pcf >>> 8, pcf,\n        cif[0], cif[1], cif[2], cif[3], cif[4], cif[5],\n        hvcC.generalLevelIdc,\n        0xF0, 0x00, // min_spatial_segmentation_idc\n        0xFC, // parallelismType\n        hvcC.chromaFormatIdc | 0xFC,\n        hvcC.bitDepthLumaMinus8 | 0xF8,\n        hvcC.bitDepthChromaMinus8 | 0xF8,\n        0x00, 0x00, // avgFrameRate\n        hvcC.numTemporalLayers << 3 | hvcC.temporalIdNested << 2 | 3,\n        numOfArrays\n      ]\n      const write = (x) => {\n        data.push(x.length >> 8, x.length)\n        data.push(...x)\n      }\n      if (vps.length) {\n        data.push(0xA0, 0x00, vps.length)\n        vps.forEach(write)\n      }\n      if (sps.length) {\n        data.push(0xA1, 0x00, sps.length)\n        sps.forEach(write)\n      }\n      if (pps.length) {\n        data.push(0xA2, 0x00, pps.length)\n        pps.forEach(write)\n      }\n    } else {\n      data = [\n        0x01, // configurationVersion\n        0x01, // profile_space + tier_flag + profile_idc\n        0x60, 0x00, 0x00, 0x00, // general_profile_compatibility\n        0x90, 0x00, 0x00, 0x00, 0x00, 0x00, // constraint_indicator_flags\n        0x5D, // level_idc=90\n        0xF0, 0x00, 0xFC, 0xFD, // profile_compatibility_indications\n        0xF8, // ‘11111’b + bitDepthLumaMinus8\n        0xF8, // ‘11111’b + bitDepthChromaMinus8\n        0x00, 0x00, // avgFrameRate\n        0x0F, // constantFrameRate + numTemporalLayers + ‘1’b + lengthSizeMinusOne\n        0x03, // numOfArrays\n\n        // vps\n        0xA0, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x18, // nalUnitLength\n        0x40, 0x01, 0x0C, 0x01, 0xFF, 0xFF, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0x99, 0x98, 0x09,\n\n        // sps\n        0xA1, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x2D, // nalUnitLength\n        0x42, 0x01, 0x01, 0x01, 0x60, 0x00, 0x00, 0x03, 0x00, 0x90, 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00, 0x5D, 0xA0, 0x02,\n        0x80, 0x80, 0x2D, 0x16, 0x59, 0x99, 0xA4, 0x93, 0x2B, 0x9A, 0x80, 0x80, 0x80, 0x82, 0x00, 0x00, 0x03, 0x00, 0x02, 0x00,\n        0x00, 0x03, 0x00, 0x32, 0x10,\n\n        // pps\n        0xA2, 0x00, 0x01, // array_completeness + ‘0’b + NAL_unit_type + numNalus\n        0x00, 0x07, // nalUnitLength\n        0x44, 0x01, 0xC1, 0x72, 0xB4, 0x62, 0x40\n      ]\n    }\n    return MP4.box(MP4.types.hvcC, new Uint8Array(data))\n  }\n\n  static pasp ([hSpacing, vSpacing]) {\n    return MP4.box(MP4.types.pasp, new Uint8Array([\n      hSpacing >> 24, (hSpacing >> 16) & 0xff, (hSpacing >> 8) & 0xff, hSpacing & 0xff,\n      vSpacing >> 24, (vSpacing >> 16) & 0xff, (vSpacing >> 8) & 0xff, vSpacing & 0xff\n    ]))\n  }\n\n  static mp4a (track) {\n    return MP4.box(MP4.types.mp4a, new Uint8Array([\n      0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, // reserved\n      0x00, 0x01, // data_reference_index\n      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // reserved\n      0x00, track.channelCount,\n      0x00, 0x10, // sampleSize:16bits\n      0x00, 0x00, // pre_defined\n      0x00, 0x00, // reserved\n      (track.sampleRate >> 8) & 0xff, track.sampleRate & 0xff,\n      0x00, 0x00\n    ]), track.config.length ? MP4.esds(track.config) : undefined)\n  }\n\n  static esds (config) {\n    const len = config.length\n    const esds = MP4.box(MP4.types.esds, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      0x03, // tag\n      0x17 + len, // length\n      0x00, 0x00, // ES_ID\n      0x00, // streamDependenceFlag, URL_flag, reserved, streamPriority\n      0x04, // tag\n      0x0f + len, // length\n      0x40, // object type\n      0x15, // streamType\n      0x00, 0x06, 0x00, // bufferSizeDB\n      0x00, 0x00, 0xda, 0xc0, // maxBitrate\n      0x00, 0x00, 0xda, 0xc0, // avgBitrate\n      0x05 // tag, DecoderSpecificInfoTag\n    ].concat([len])\n      .concat(config)\n      .concat(\n        [0x06, 0x01, 0x02]// GASpecificConfig\n      )\n    ))\n    // console.log('[remux],esds ,len ', esds.byteLength, hashVal(esds.toString()))\n    return esds\n  }\n\n  static mvex (tracks) {\n    // const mehd = MP4.box(MP4.types.mehd, this.extension(0, 0), Buffer.writeUint32(tracks[0].tkhdDuration))\n    // const mvex = MP4.box(MP4.types.mvex, mehd, MP4.trex1(1), MP4.trex2(2))\n    // // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    // const mvex = MP4.box(MP4.types.mvex, MP4.trex1(1), MP4.trex2(2))\n    const mvex = MP4.box(MP4.types.mvex, ...tracks.map((t) => MP4.trex(t.id)))\n    // console.log('[remux],mvex, len,', mvex.byteLength, hashVal(mvex.toString()))\n    return mvex\n  }\n\n  static trex (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff, // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x00, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x01 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex1 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x02, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x00, 0x01, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static trex2 (id) {\n    const trex = MP4.box(MP4.types.trex, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags\n      (id >> 24),\n      (id >> 16) & 0xff,\n      (id >> 8) & 0xff,\n      (id & 0xff), // track_ID\n      0x00, 0x00, 0x00, 0x01, // default_sample_description_index\n      0x00, 0x00, 0x04, 0x00, // default_sample_duration\n      0x00, 0x00, 0x00, 0x00, // default_sample_size\n      0x02, 0x00, 0x00, 0x00 // default_sample_flags\n    ]))\n    // console.log('[remux],trex, len,', trex.byteLength, hashVal(trex.toString()))\n    return trex\n  }\n\n  static moof (tracks) {\n    const moof = MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].samples ? tracks[0].samples[0].gopId : 0), ...tracks.map((t) => MP4.traf(t)))\n    // console.log('[remux],moof, len', moof.byteLength)\n    return moof\n    // return MP4.box(MP4.types.moof, MP4.mfhd(tracks[0].gopId), ...tracks.map((t) => MP4.traf(t)))\n  }\n\n  static mfhd (sequenceNumber) {\n    // sequenceNumber += 1\n    const mfhd = MP4.box(MP4.types.mfhd, new Uint8Array([\n      0x00, // version\n      0x00, 0x00, 0x00, // flags\n      sequenceNumber >> 24, (sequenceNumber >> 16) & 0xff, (sequenceNumber >> 8) & 0xff, sequenceNumber & 0xff\n    ]))\n    // console.log('[remux],mfhd, len,', mfhd.byteLength, hashVal(mfhd.toString()))\n    return mfhd\n  }\n\n  static traf (track) {\n    const tfhd = MP4.tfhd(track.id)\n    // console.log('[remux],tfhd, len,', tfhd.byteLength, hashVal(tfhd.toString()), ', trackid = ', track.id)\n    // console.log('[remux],tfdt,baseMediaDecodeTime,', track.baseMediaDecodeTime)\n    const tfdt = MP4.tfdt(track, track.baseMediaDecodeTime)\n    let sencLength = 0\n    let samples\n    if (track.isVideo && track.videoSenc) {\n      samples = track.videoSenc\n      samples.forEach(function (item) {\n        sencLength = sencLength + 8\n        if (item.subsamples && item.subsamples.length) {\n          sencLength = sencLength + 2\n          sencLength = sencLength + item.subsamples.length * 6\n        }\n      })\n    }\n    track.videoSencLength = sencLength\n    // console.log('[remux],tfdt, len,', tfdt.toString().length)\n    // console.log('[remux],tfdt, len,', tfdt.byteLength, hashVal(tfdt.toString()))\n    if (!track.useEME || (!track.isVideoEncryption && !track.isAudioEncryption)) {\n      const sdtp = MP4.sdtp(track)\n      // console.log('[remux],sdtp, len,', sdtp.byteLength, hashVal(sdtp.toString()))\n      const offset = 16 + // tfhd\n        20 + // tfdt\n        8 + // traf header\n        16 + // mfhd\n        8 + // moof header\n        8 // mdat header\n      return MP4.box(MP4.types.traf, tfhd, tfdt, sdtp, MP4.trun(track.samples, sdtp.byteLength + offset))\n    } else if (track.isVideoEncryption) {\n      if (track.isVideo) {\n        // 加密视频\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const trun = MP4.trun1(track)\n        const senc = MP4.senc(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, saiz, saio, trun, senc)\n        // console.log('[remux],trex_video, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      } else {\n        // 视频加密，音频加密和未加密处理\n        if (!track.isAudioEncryption) {\n          // 音频未加密\n          const sbgp = MP4.sbgp()\n          const trun = MP4.trun1(track)\n          return MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, trun)\n        } else {\n          // 音频加密\n          const sbgp = MP4.sbgp()\n          const saiz = MP4.saiz(track)\n          const saio = MP4.saio(track)\n          const senc = MP4.senc(track)\n          const trun = MP4.trun1(track)\n          const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n          // console.log('[remux],trex_audio, len,', traf.byteLength, hashVal(traf.toString()))\n          return traf\n        }\n      }\n    } else {\n      // 视频未加密，音频加密\n      if (track.isVideo) {\n        const trun = MP4.trun1(track)\n        return MP4.box(MP4.types.traf, tfhd, tfdt, trun)\n      } else {\n        const sbgp = MP4.sbgp()\n        const saiz = MP4.saiz(track)\n        const saio = MP4.saio(track)\n        const senc = MP4.senc(track)\n        const trun = MP4.trun1(track)\n        const traf = MP4.box(MP4.types.traf, tfhd, tfdt, sbgp, saiz, saio, senc, trun)\n        // console.log('[remux],trex, len,', traf.byteLength, hashVal(traf.toString()))\n        return traf\n      }\n    }\n  }\n\n  static sdtp (data) {\n    const buffer = new Buffer()\n    data.samples.forEach(item => {\n      buffer.write(new Uint8Array(data.isVideo ? [item.keyframe ? 32 : 16] : [16]))\n    })\n    return MP4.box(MP4.types.sdtp, this.extension(0, 0), buffer.buffer)\n  }\n\n  static trun1 (data) {\n    // const id = data.id\n    // const ceil = id === 1 ? 12 : 4\n    const buffer = new Buffer()\n    const sampleCount = Buffer.writeUint32(data.samples.length)\n    let offset = null\n    if (data.isVideo) {\n      const sencLength = data.videoSencLength\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      17 + //saiz\n      24 + //saio\n      data.samples.length*16\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      12(header) + sencLength //senc\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n      = 149+data.samples.length * 16 + sencLength\n       */\n      offset = Buffer.writeUint32(data.samples.length * 16 + sencLength + 149)\n      if (!data.isVideoEncryption && data.isAudioEncryption) {\n        offset = Buffer.writeUint32(data.samples.length * 16 + 92)\n      }\n    } else {\n      /*\n      16 + // mfhd\n      16 + // tfhd\n      20 + // tfdt\n      28 + //sbgp\n      4(offset) + 4(sampleCount) + 12(header)  //trun\n      8 + // traf header\n      8 + // moof header\n      8 // mdat header\n       */\n      let len = data.samples.length * 12 + 124\n      if (data.isAudioEncryption) {\n        len = data.samples.length * 12 + 8 * data.audioSenc.length + 177\n      }\n      offset = Buffer.writeUint32(len)\n    }\n\n    data.samples.forEach(item => {\n      buffer.write(Buffer.writeUint32(item.duration))\n      buffer.write(Buffer.writeUint32(item.size))\n      buffer.write(Buffer.writeUint32(item.keyframe ? 0x02000000 : 0x00010000))\n      if (data.isVideo) {\n        buffer.write(Buffer.writeUint32(item.cts ? item.cts : 0))\n      }\n    })\n\n    return MP4.box(MP4.types.trun, this.extension(0, data.flags), sampleCount, offset, buffer.buffer)\n  }\n\n  static senc (data) {\n    const buffer = new Buffer()\n    const len = data.samples.length\n    const ceil = data.isVideo ? 16 : 8\n    const flag = data.isVideo ? 2 : 0\n    let samples = []\n    let samplesLength = 0\n    if (data.isVideo) {\n      samples = data.videoSenc\n      samplesLength = data.videoSencLength\n    } else {\n      samples = data.audioSenc\n    }\n    samplesLength = samplesLength || ceil * len\n    buffer.write(\n      Buffer.writeUint32(16 + samplesLength), MP4.types.senc, this.extension(0, flag)\n    )\n    buffer.write(Buffer.writeUint32(len))\n    samples.forEach(item => {\n      for (let i = 0; i < item.InitializationVector.length; i++) {\n        buffer.write(new Uint8Array([item.InitializationVector[i]]))\n      }\n      if (item.subsamples && item.subsamples.length) {\n        buffer.write(Buffer.writeUint16(item.subsamples.length))\n        item.subsamples.forEach(value => {\n          buffer.write(Buffer.writeUint16(value.BytesOfClearData))\n          buffer.write(Buffer.writeUint32(value.BytesOfProtectedData))\n        })\n      }\n    })\n    return buffer.buffer\n    // return MP4.box(MP4.types.senc, this.extension(0, flag), buffer.buffer)\n  }\n\n  static saio (data) {\n    let length = data.samples.length * 12 + 141\n    if (!data.isVideo && data.isAudioEncryption) {\n      length = 149\n    }\n    const content = new Uint8Array([\n      0x01, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x00, 0x00,\n      (length >> 24) & 0xff,\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff\n    ])\n    return MP4.box(MP4.types.saio, content)\n  }\n\n  static saiz (data) {\n    const samplesLength = data.samples.length\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x10, // default sample info size\n      (samplesLength >> 24) & 0xff,\n      (samplesLength >> 16) & 0xff,\n      (samplesLength >> 8) & 0xff,\n      samplesLength & 0xff\n    ])\n    return MP4.box(MP4.types.saiz, content)\n  }\n\n  static sbgp () {\n    const content = new Uint8Array([\n      0x72, 0x6F, 0x6C, 0x6C, // sgpd, grouping_type\n      0x00, 0x00, 0x00, 0x01,\n      0x00, 0x00, 0x01, 0x19,\n      0x00, 0x00, 0x00, 0x01\n    ])\n    return MP4.box(MP4.types.sbgp, this.extension(0, 0), content)\n  }\n\n  static extension (version, flag) {\n    return new Uint8Array([\n      version,\n      (flag >> 16) & 0xff,\n      (flag >> 8) & 0xff,\n      flag & 0xff\n    ])\n  }\n\n  static tfhd (id) {\n    return MP4.box(MP4.types.tfhd, new Uint8Array([\n      0x00, // version 0\n      0x00, 0x00, 0x00, // flags todo 0x00\n      id >> 24, (id >> 16) & 0xff, (id >> 8) & 0xff, id & 0xff // track_ID\n    ]))\n  }\n\n  static tfdt (data, baseMediaDecodeTime) {\n    const upperWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime / (UINT32_MAX + 1))\n    const lowerWordBaseMediaDecodeTime = Math.floor(baseMediaDecodeTime % (UINT32_MAX + 1))\n    if (data.useEME && (data.isVideoEncryption || data.isAudioEncryption)) {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x00, // version 0\n        0x00, 0x00, 0x00, // flags\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    } else {\n      return MP4.box(MP4.types.tfdt, new Uint8Array([\n        0x01, // version 1\n        0x00, 0x00, 0x00, // flags\n        upperWordBaseMediaDecodeTime >> 24,\n        (upperWordBaseMediaDecodeTime >> 16) & 0xff,\n        (upperWordBaseMediaDecodeTime >> 8) & 0xff,\n        upperWordBaseMediaDecodeTime & 0xff,\n        lowerWordBaseMediaDecodeTime >> 24,\n        (lowerWordBaseMediaDecodeTime >> 16) & 0xff,\n        (lowerWordBaseMediaDecodeTime >> 8) & 0xff,\n        lowerWordBaseMediaDecodeTime & 0xff\n      ]))\n    }\n  }\n\n  static trun (samples, offset) {\n    const sampleLen = samples.length\n    const dataLen = 12 + (16 * sampleLen)\n    offset += 8 + dataLen\n    const data = new Uint8Array(dataLen)\n    data.set([\n      0x00, // version\n      0x00, 0x0f, 0x01, // flags\n      (sampleLen >>> 24) & 0xff, (sampleLen >>> 16) & 0xff, (sampleLen >>> 8) & 0xff, sampleLen & 0xff,\n      (offset >>> 24) & 0xff, (offset >>> 16) & 0xff, (offset >>> 8) & 0xff, offset & 0xff // data_offset\n    ], 0)\n    for (let i = 0; i < sampleLen; i++) {\n      const {\n        duration, size, flag = {}, cts = 0\n      } = samples[i]\n      data.set([\n        (duration >>> 24) & 0xff, (duration >>> 16) & 0xff, (duration >>> 8) & 0xff, duration & 0xff,\n        (size >>> 24) & 0xff, (size >>> 16) & 0xff, (size >>> 8) & 0xff, size & 0xff,\n        (flag.isLeading << 2) | (flag.dependsOn === null || flag.dependsOn === undefined ? 1 : flag.dependsOn),\n        (flag.isDependedOn << 6) | (flag.hasRedundancy << 4) | (flag.paddingValue << 1) | (flag.isNonSyncSample === null || flag.isNonSyncSample === undefined ? 1 : flag.isNonSyncSample),\n        flag.degradationPriority & (0xf0 << 8), flag.degradationPriority & 0x0f, // sample_flags\n        (cts >>> 24) & 0xff, (cts >>> 16) & 0xff, (cts >>> 8) & 0xff, cts & 0xff // sample_composition_time_offset\n      ], 12 + 16 * i)\n    }\n\n    return MP4.box(MP4.types.trun, data)\n  }\n\n  static moovMP4 (tracks) {\n    return MP4.box(MP4.types.moov,\n      MP4.mvhd(tracks[0].duration, tracks[0].timescale),\n      ...tracks.map((t) => MP4.trackMP4(t)))\n  }\n\n  static trackMP4 (track) {\n    return MP4.box(\n      MP4.types.trak,\n      MP4.tkhd(track.id, track.duration, track.width, track.height),\n      MP4.mdiaMP4(track)\n    )\n  }\n\n  static mdiaMP4 (track) {\n    return MP4.box(MP4.types.mdia, MP4.mdhd(track.duration, track.timescale), MP4.hdlr(track.type), MP4.minfMP4(track))\n  }\n\n  static minfMP4 (track) {\n    return MP4.box(MP4.types.minf, track.type === TrackType.VIDEO ? MP4.VMHD : MP4.SMHD, MP4.DINF, MP4.stblMP4(track))\n  }\n\n  static stblMP4 (track) {\n    const { ext } = track\n    const boxes = [\n      MP4.stsd(track),\n      MP4.stts(ext.stts),\n      MP4.stsc(ext.stsc),\n      MP4.stsz(ext.stsz),\n      MP4.stco(ext.stco)\n    ]\n\n    if (ext.stss.length) {\n      boxes.push(MP4.stss(ext.stss))\n    }\n\n    if (ext.ctts.length) {\n      boxes.push(MP4.ctts(ext.ctts))\n    }\n\n    return MP4.box(MP4.types.stbl, ...boxes)\n  }\n\n  static stts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n\n    return MP4.box(MP4.types.stts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsc (entries) {\n    const len = entries.length\n    const data = new Uint8Array(12 * len)\n    let offset = 0\n    entries.forEach(({ firstChunk, samplesPerChunk, sampleDescIndex }) => {\n      data.set([\n        firstChunk >> 24, (firstChunk >> 16) & 0xff, (firstChunk >> 8) & 0xff, firstChunk & 0xff,\n        samplesPerChunk >> 24, (samplesPerChunk >> 16) & 0xff, (samplesPerChunk >> 8) & 0xff, samplesPerChunk & 0xff,\n        sampleDescIndex >> 24, (sampleDescIndex >> 16) & 0xff, (sampleDescIndex >> 8) & 0xff, sampleDescIndex & 0xff\n      ], offset)\n      offset += 12\n    })\n    return MP4.box(MP4.types.stsc, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      (len >> 24), (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static stsz (samplesSizes) {\n    const len = samplesSizes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    samplesSizes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stsz, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stco (offsets) {\n    const len = offsets.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    offsets.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stco, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static stss (keyframeIndexes) {\n    const len = keyframeIndexes.length\n    const data = new Uint8Array(4 * len)\n    let offset = 0\n    keyframeIndexes.forEach((x) => {\n      data.set([\n        x >> 24, (x >> 16) & 0xff, (x >> 8) & 0xff, x & 0xff\n      ], offset)\n      offset += 4\n    })\n    return MP4.box(MP4.types.stss, concatUint8Array(\n      new Uint8Array([\n        0, 0, 0, 0,\n        len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n      ]),\n      data\n    ))\n  }\n\n  static ctts (samples) {\n    const len = samples.length\n    const data = new Uint8Array(8 * len)\n    let offset = 0\n    samples.forEach(({ value, count }) => {\n      data.set([\n        count >> 24, (count >> 16) & 0xff, (count >> 8) & 0xff, count & 0xff,\n        value >> 24, (value >> 16) & 0xff, (value >> 8) & 0xff, value & 0xff\n      ], offset)\n      offset += 8\n    })\n    return MP4.box(MP4.types.ctts, concatUint8Array(new Uint8Array([\n      0, 0, 0, 0,\n      len >> 24, (len >> 16) & 0xff, (len >> 8) & 0xff, len & 0xff\n    ]), data))\n  }\n\n  static styp () {\n    return MP4.box(MP4.types.styp, new Uint8Array([\n      0x6D, 0x73, 0x64, 0x68,\n      0x00, 0x00, 0x00, 0x00,\n      0x6D, 0x73, 0x64, 0x68,\n      0x6D, 0x73, 0x69, 0x78\n    ]))\n  }\n\n  // data.sampleOffset 指的是samples的序列号。_samples[0].idx\n  static sidx (data) {\n    // const buffer = new Buffer()\n    const timescale = data.timescale\n    const duration = data.samples[0].duration\n    const durationCount = duration * data.samples.length\n    const earliestTime = data.samples[0].sampleOffset * duration\n    let mdatSize = 8\n    data.samples.forEach(item => {\n      mdatSize += item.size\n    })\n    let length = 0\n    if (data.isVideo) {\n      let sencLength = 0\n      let samples\n      if (data.videoSenc) {\n        samples = data.videoSenc\n      }\n      if (data.isVideo) {\n        samples.forEach(item => {\n          sencLength = sencLength + 8\n          if (item.subsamples && item.subsamples.length) {\n            sencLength = sencLength + 2\n            sencLength = sencLength + item.subsamples.length * 6\n          }\n        })\n      }\n      data.videoSencLength = sencLength\n      length = mdatSize + 141 + data.samples.length * 16 + sencLength\n      if (data.useEME && data.isAudioEncryption && !data.isVideoEncryption) {\n        length = mdatSize + (data.samples.length * 16) + 84\n      }\n    } else {\n      length = mdatSize + 116 + data.samples.length * 12\n      if (data.useEME && data.isAudioEncryption) {\n        length = mdatSize + 169 + data.samples.length * 12 + 8 * data.audioSenc.length\n      }\n    }\n\n    const content = new Uint8Array([\n      0x00, 0x00, 0x00, 0x00,\n      0x00, 0x00, 0x00, data.id & 0xff, // ref_id\n      (timescale >> 24) & 0xff,\n      (timescale >> 16) & 0xff,\n      (timescale >> 8) & 0xff,\n      timescale & 0xff, // timescale\n      (earliestTime >> 24) & 0xff,\n      (earliestTime >> 16) & 0xff,\n      (earliestTime >> 8) & 0xff,\n      earliestTime & 0xff, // earliest_presentation_time\n      0x00, 0x00, 0x00, 0x00, // first_offset\n      0x00, 0x00, // reserved\n      0x00, 0x01, // ref_count\n      // 0x00, 0x04, 0x11, 0xCF, // ref_size + ref_type\n      // 0x00, 0x01, 0x0A, 0xA6, // ref_size + ref_type\n      0x00, // ref_size + ref_type ref_size = moof.size + mdat.size\n      (length >> 16) & 0xff,\n      (length >> 8) & 0xff,\n      length & 0xff,\n      (durationCount >> 24) & 0xff,\n      (durationCount >> 16) & 0xff,\n      (durationCount >> 8) & 0xff,\n      durationCount & 0xff,\n      0x90, 0x00, 0x00, 0x00\n    ])\n    return MP4.box(MP4.types.sidx, content)\n  }\n\n  static mdat (data) {\n    const mdat = MP4.box(MP4.types.mdat, data)\n    // console.log('[remux],mdat ,len ', mdat.byteLength, hashVal(mdat.toString()))\n    return mdat\n  }\n}\n","\nexport class Logger {\n  constructor (name, enable) {\n    this.name = name || ''\n    this._prefix = `[${this.name}]`\n    Logger.disabled = enable\n  }\n\n  debug (...args) {\n    if (Logger.disabled) return\n    console.debug(this._prefix, ...args)\n  }\n\n  log (...args) {\n    if (Logger.disabled) return\n    console.log(this._prefix, ...args)\n  }\n\n  warn (...args) {\n    if (Logger.disabled) return\n    console.warn(this._prefix, ...args)\n  }\n\n  error (...args) {\n    if (Logger.disabled) return\n    console.error(this._prefix, ...args)\n  }\n\n  table (...args) {\n    if (Logger.disabled) return\n    console.group(this._prefix)\n    console.table(...args)\n    console.groupEnd()\n  }\n\n  static disabled = true\n\n  static enable () {\n    Logger.disabled = false\n  }\n\n  static disable () {\n    Logger.disabled = true\n  }\n}\n","import {\n  WordArray,\n  Hasher,\n} from './core.js';\n\n// Constants table\nconst T = [];\n\n// Compute constants\nfor (let i = 0; i < 64; i += 1) {\n  T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n}\n\nconst FF = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & c) | (~b & d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst GG = (a, b, c, d, x, s, t) => {\n  const n = a + ((b & d) | (c & ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst HH = (a, b, c, d, x, s, t) => {\n  const n = a + (b ^ c ^ d) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\nconst II = (a, b, c, d, x, s, t) => {\n  const n = a + (c ^ (b | ~d)) + x + t;\n  return ((n << s) | (n >>> (32 - s))) + b;\n};\n\n/**\n * MD5 hash algorithm.\n */\nexport class MD5Algo extends Hasher {\n  _doReset() {\n    this._hash = new WordArray([\n      0x67452301,\n      0xefcdab89,\n      0x98badcfe,\n      0x10325476,\n    ]);\n  }\n\n  _doProcessBlock(M, offset) {\n    const _M = M;\n\n    // Swap endian\n    for (let i = 0; i < 16; i += 1) {\n      // Shortcuts\n      const offset_i = offset + i;\n      const M_offset_i = M[offset_i];\n\n      _M[offset_i] = (\n        (((M_offset_i << 8) | (M_offset_i >>> 24)) & 0x00ff00ff)\n          | (((M_offset_i << 24) | (M_offset_i >>> 8)) & 0xff00ff00)\n      );\n    }\n\n    // Shortcuts\n    const H = this._hash.words;\n\n    const M_offset_0 = _M[offset + 0];\n    const M_offset_1 = _M[offset + 1];\n    const M_offset_2 = _M[offset + 2];\n    const M_offset_3 = _M[offset + 3];\n    const M_offset_4 = _M[offset + 4];\n    const M_offset_5 = _M[offset + 5];\n    const M_offset_6 = _M[offset + 6];\n    const M_offset_7 = _M[offset + 7];\n    const M_offset_8 = _M[offset + 8];\n    const M_offset_9 = _M[offset + 9];\n    const M_offset_10 = _M[offset + 10];\n    const M_offset_11 = _M[offset + 11];\n    const M_offset_12 = _M[offset + 12];\n    const M_offset_13 = _M[offset + 13];\n    const M_offset_14 = _M[offset + 14];\n    const M_offset_15 = _M[offset + 15];\n\n    // Working varialbes\n    let a = H[0];\n    let b = H[1];\n    let c = H[2];\n    let d = H[3];\n\n    // Computation\n    a = FF(a, b, c, d, M_offset_0, 7, T[0]);\n    d = FF(d, a, b, c, M_offset_1, 12, T[1]);\n    c = FF(c, d, a, b, M_offset_2, 17, T[2]);\n    b = FF(b, c, d, a, M_offset_3, 22, T[3]);\n    a = FF(a, b, c, d, M_offset_4, 7, T[4]);\n    d = FF(d, a, b, c, M_offset_5, 12, T[5]);\n    c = FF(c, d, a, b, M_offset_6, 17, T[6]);\n    b = FF(b, c, d, a, M_offset_7, 22, T[7]);\n    a = FF(a, b, c, d, M_offset_8, 7, T[8]);\n    d = FF(d, a, b, c, M_offset_9, 12, T[9]);\n    c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n    b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n    a = FF(a, b, c, d, M_offset_12, 7, T[12]);\n    d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n    c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n    b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n    a = GG(a, b, c, d, M_offset_1, 5, T[16]);\n    d = GG(d, a, b, c, M_offset_6, 9, T[17]);\n    c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n    b = GG(b, c, d, a, M_offset_0, 20, T[19]);\n    a = GG(a, b, c, d, M_offset_5, 5, T[20]);\n    d = GG(d, a, b, c, M_offset_10, 9, T[21]);\n    c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n    b = GG(b, c, d, a, M_offset_4, 20, T[23]);\n    a = GG(a, b, c, d, M_offset_9, 5, T[24]);\n    d = GG(d, a, b, c, M_offset_14, 9, T[25]);\n    c = GG(c, d, a, b, M_offset_3, 14, T[26]);\n    b = GG(b, c, d, a, M_offset_8, 20, T[27]);\n    a = GG(a, b, c, d, M_offset_13, 5, T[28]);\n    d = GG(d, a, b, c, M_offset_2, 9, T[29]);\n    c = GG(c, d, a, b, M_offset_7, 14, T[30]);\n    b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n    a = HH(a, b, c, d, M_offset_5, 4, T[32]);\n    d = HH(d, a, b, c, M_offset_8, 11, T[33]);\n    c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n    b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n    a = HH(a, b, c, d, M_offset_1, 4, T[36]);\n    d = HH(d, a, b, c, M_offset_4, 11, T[37]);\n    c = HH(c, d, a, b, M_offset_7, 16, T[38]);\n    b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n    a = HH(a, b, c, d, M_offset_13, 4, T[40]);\n    d = HH(d, a, b, c, M_offset_0, 11, T[41]);\n    c = HH(c, d, a, b, M_offset_3, 16, T[42]);\n    b = HH(b, c, d, a, M_offset_6, 23, T[43]);\n    a = HH(a, b, c, d, M_offset_9, 4, T[44]);\n    d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n    c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n    b = HH(b, c, d, a, M_offset_2, 23, T[47]);\n\n    a = II(a, b, c, d, M_offset_0, 6, T[48]);\n    d = II(d, a, b, c, M_offset_7, 10, T[49]);\n    c = II(c, d, a, b, M_offset_14, 15, T[50]);\n    b = II(b, c, d, a, M_offset_5, 21, T[51]);\n    a = II(a, b, c, d, M_offset_12, 6, T[52]);\n    d = II(d, a, b, c, M_offset_3, 10, T[53]);\n    c = II(c, d, a, b, M_offset_10, 15, T[54]);\n    b = II(b, c, d, a, M_offset_1, 21, T[55]);\n    a = II(a, b, c, d, M_offset_8, 6, T[56]);\n    d = II(d, a, b, c, M_offset_15, 10, T[57]);\n    c = II(c, d, a, b, M_offset_6, 15, T[58]);\n    b = II(b, c, d, a, M_offset_13, 21, T[59]);\n    a = II(a, b, c, d, M_offset_4, 6, T[60]);\n    d = II(d, a, b, c, M_offset_11, 10, T[61]);\n    c = II(c, d, a, b, M_offset_2, 15, T[62]);\n    b = II(b, c, d, a, M_offset_9, 21, T[63]);\n\n    // Intermediate hash value\n    H[0] = (H[0] + a) | 0;\n    H[1] = (H[1] + b) | 0;\n    H[2] = (H[2] + c) | 0;\n    H[3] = (H[3] + d) | 0;\n  }\n  /* eslint-ensable no-param-reassign */\n\n  _doFinalize() {\n    // Shortcuts\n    const data = this._data;\n    const dataWords = data.words;\n\n    const nBitsTotal = this._nDataBytes * 8;\n    const nBitsLeft = data.sigBytes * 8;\n\n    // Add padding\n    dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - (nBitsLeft % 32));\n\n    const nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n    const nBitsTotalL = nBitsTotal;\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n      (((nBitsTotalH << 8) | (nBitsTotalH >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalH << 24) | (nBitsTotalH >>> 8)) & 0xff00ff00)\n    );\n    dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n      (((nBitsTotalL << 8) | (nBitsTotalL >>> 24)) & 0x00ff00ff)\n        | (((nBitsTotalL << 24) | (nBitsTotalL >>> 8)) & 0xff00ff00)\n    );\n\n    data.sigBytes = (dataWords.length + 1) * 4;\n\n    // Hash final blocks\n    this._process();\n\n    // Shortcuts\n    const hash = this._hash;\n    const H = hash.words;\n\n    // Swap endian\n    for (let i = 0; i < 4; i += 1) {\n      // Shortcut\n      const H_i = H[i];\n\n      H[i] = (((H_i << 8) | (H_i >>> 24)) & 0x00ff00ff)\n        | (((H_i << 24) | (H_i >>> 8)) & 0xff00ff00);\n    }\n\n    // Return final computed hash\n    return hash;\n  }\n\n  clone() {\n    const clone = super.clone.call(this);\n    clone._hash = this._hash.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Shortcut function to the hasher's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n *\n * @return {WordArray} The hash.\n *\n * @static\n *\n * @example\n *\n *     var hash = CryptoJS.MD5('message');\n *     var hash = CryptoJS.MD5(wordArray);\n */\nexport const MD5 = Hasher._createHelper(MD5Algo);\n\n/**\n * Shortcut function to the HMAC's object interface.\n *\n * @param {WordArray|string} message The message to hash.\n * @param {WordArray|string} key The secret key.\n *\n * @return {WordArray} The HMAC.\n *\n * @static\n *\n * @example\n *\n *     var hmac = CryptoJS.HmacMD5(message, key);\n */\nexport const HmacMD5 = Hasher._createHmacHelper(MD5Algo);\n","import { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\nimport { Logger } from './logger'\n\n/**\n * @typedef {Object} RemuxResult\n * @property {Uint8Array} [videoInitSegment]\n * @property {Uint8Array} [audioInitSegment]\n * @property {Uint8Array} [videoSegment]\n * @property {Uint8Array} [audioSegment]\n */\n\nexport class FMP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack, options) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n    const browserVersions = /Chrome\\/([^.]+)/.exec(navigator.userAgent)\n    this.forceFirstIDR = browserVersions && Number(browserVersions[1]) < 50\n    this.log = new Logger('FMP4Remuxer', options && options.openLog ? !options.openLog : true)\n  }\n\n  /**\n   * @param {boolean} [createInit=false]\n   * @returns {RemuxResult}\n   */\n  remux (createInit = false, options = {}) {\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n    const hasVideo = videoTrack.exist()\n    const hasAudio = audioTrack.exist()\n\n    let videoInitSegment\n    let audioInitSegment\n\n    let initSegment\n    const tracks = []\n\n    if (createInit) {\n      if (options && options.initMerge) {\n        if (hasVideo) {\n          tracks.push(this.videoTrack)\n        }\n        if (hasAudio) {\n          tracks.push(this.audioTrack)\n        }\n        initSegment = MP4.initSegment(tracks)\n      } else {\n        if (hasVideo) videoInitSegment = MP4.initSegment([this.videoTrack])\n        if (hasAudio) audioInitSegment = MP4.initSegment([this.audioTrack])\n      }\n    }\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && videoTrack.hasSample()) {\n      videoSegment = this._remuxVideo()\n    }\n\n    if (hasAudio && audioTrack.hasSample()) {\n      audioSegment = this._remuxAudio()\n    }\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return {\n      initSegment,\n      videoInitSegment,\n      audioInitSegment,\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxVideo () {\n    const track = this.videoTrack\n    if (this.forceFirstIDR) {\n      track.samples[0].flag = { dependsOn: 2, isNonSyncSample: 0 }\n    }\n    const samples = track.samples\n\n    let mdatSize = 0\n\n    samples.forEach((s) => {\n      mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n      mdatSize += (s.units.length * 4)\n    })\n\n    const mdata = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdata.buffer)\n\n    for (let i = 0, l = samples.length, offset = 0, sample; i < l; i++) {\n      sample = samples[i]\n\n      let sampleSize = 0\n      sample.units.forEach((u) => {\n        mdatView.setUint32(offset, u.byteLength)\n        offset += 4\n        mdata.set(u, offset)\n        offset += u.byteLength\n        sampleSize += (4 + u.byteLength)\n      })\n      sample.size = sampleSize\n    }\n    const mdat = MP4.mdat(mdata)\n\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n\n  }\n\n  _remuxAudio () {\n    const track = this.audioTrack\n    const mdata = new Uint8Array(track.samples.reduce((t, c) => (t + c.size), 0))\n    track.samples.reduce((offset, s) => {\n      mdata.set(s.data, offset)\n      return offset + s.size\n    }, 0)\n    const mdat = MP4.mdat(mdata)\n    const moof = MP4.moof([track])\n    return concatUint8Array(moof, mdat)\n  }\n\n  reset () {\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n  }\n}\n","/* eslint-disable no-use-before-define */\n\n/**\n * Base class for inheritance.\n */\nexport class Base {\n  /**\n   * Extends this object and runs the init method.\n   * Arguments to create() will be passed to init().\n   *\n   * @return {Object} The new object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var instance = MyType.create();\n   */\n  static create(...args) {\n    return new this(...args);\n  }\n\n  /**\n   * Copies properties into this object.\n   *\n   * @param {Object} properties The properties to mix in.\n   *\n   * @example\n   *\n   *     MyType.mixIn({\n   *         field: 'value'\n   *     });\n   */\n  mixIn(properties) {\n    return Object.assign(this, properties);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = instance.clone();\n   */\n  clone() {\n    const clone = new this.constructor();\n    Object.assign(clone, this);\n    return clone;\n  }\n}\n\n/**\n * An array of 32-bit words.\n *\n * @property {Array} words The array of 32-bit words.\n * @property {number} sigBytes The number of significant bytes in this word array.\n */\nexport class WordArray extends Base {\n  /**\n   * Initializes a newly created word array.\n   *\n   * @param {Array} words (Optional) An array of 32-bit words.\n   * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.create();\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n   *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n   */\n  constructor(words = [], sigBytes = words.length * 4) {\n    super();\n\n    let typedArray = words;\n    // Convert buffers to uint8\n    if (typedArray instanceof ArrayBuffer) {\n      typedArray = new Uint8Array(typedArray);\n    }\n\n    // Convert other array views to uint8\n    if (\n      typedArray instanceof Int8Array\n      || typedArray instanceof Uint8ClampedArray\n      || typedArray instanceof Int16Array\n      || typedArray instanceof Uint16Array\n      || typedArray instanceof Int32Array\n      || typedArray instanceof Uint32Array\n      || typedArray instanceof Float32Array\n      || typedArray instanceof Float64Array\n    ) {\n      typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n    }\n\n    // Handle Uint8Array\n    if (typedArray instanceof Uint8Array) {\n      // Shortcut\n      const typedArrayByteLength = typedArray.byteLength;\n\n      // Extract bytes\n      const _words = [];\n      for (let i = 0; i < typedArrayByteLength; i += 1) {\n        _words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n      }\n\n      // Initialize this word array\n      this.words = _words;\n      this.sigBytes = typedArrayByteLength;\n    } else {\n      // Else call normal init\n      this.words = words;\n      this.sigBytes = sigBytes;\n    }\n  }\n\n  /**\n   * Creates a word array filled with random bytes.\n   *\n   * @param {number} nBytes The number of random bytes to generate.\n   *\n   * @return {WordArray} The random word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.lib.WordArray.random(16);\n   */\n  static random(nBytes) {\n    const words = [];\n\n    const r = (m_w) => {\n      let _m_w = m_w;\n      let _m_z = 0x3ade68b1;\n      const mask = 0xffffffff;\n\n      return () => {\n        _m_z = (0x9069 * (_m_z & 0xFFFF) + (_m_z >> 0x10)) & mask;\n        _m_w = (0x4650 * (_m_w & 0xFFFF) + (_m_w >> 0x10)) & mask;\n        let result = ((_m_z << 0x10) + _m_w) & mask;\n        result /= 0x100000000;\n        result += 0.5;\n        return result * (Math.random() > 0.5 ? 1 : -1);\n      };\n    };\n\n    for (let i = 0, rcache; i < nBytes; i += 4) {\n      const _r = r((rcache || Math.random()) * 0x100000000);\n\n      rcache = _r() * 0x3ade67b7;\n      words.push((_r() * 0x100000000) | 0);\n    }\n\n    return new WordArray(words, nBytes);\n  }\n\n  /**\n   * Converts this word array to a string.\n   *\n   * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n   *\n   * @return {string} The stringified word array.\n   *\n   * @example\n   *\n   *     var string = wordArray + '';\n   *     var string = wordArray.toString();\n   *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n   */\n  toString(encoder = Hex) {\n    return encoder.stringify(this);\n  }\n\n  /**\n   * Concatenates a word array to this word array.\n   *\n   * @param {WordArray} wordArray The word array to append.\n   *\n   * @return {WordArray} This word array.\n   *\n   * @example\n   *\n   *     wordArray1.concat(wordArray2);\n   */\n  concat(wordArray) {\n    // Shortcuts\n    const thisWords = this.words;\n    const thatWords = wordArray.words;\n    const thisSigBytes = this.sigBytes;\n    const thatSigBytes = wordArray.sigBytes;\n\n    // Clamp excess bits\n    this.clamp();\n\n    // Concat\n    if (thisSigBytes % 4) {\n      // Copy one byte at a time\n      for (let i = 0; i < thatSigBytes; i += 1) {\n        const thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n        thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n      }\n    } else {\n      // Copy one word at a time\n      for (let i = 0; i < thatSigBytes; i += 4) {\n        thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n      }\n    }\n    this.sigBytes += thatSigBytes;\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Removes insignificant bits.\n   *\n   * @example\n   *\n   *     wordArray.clamp();\n   */\n  clamp() {\n    // Shortcuts\n    const { words, sigBytes } = this;\n\n    // Clamp\n    words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n    words.length = Math.ceil(sigBytes / 4);\n  }\n\n  /**\n   * Creates a copy of this word array.\n   *\n   * @return {WordArray} The clone.\n   *\n   * @example\n   *\n   *     var clone = wordArray.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone.words = this.words.slice(0);\n\n    return clone;\n  }\n}\n\n/**\n * Hex encoding strategy.\n */\nexport const Hex = {\n  /**\n   * Converts a word array to a hex string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The hex string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const hexChars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      hexChars.push((bite >>> 4).toString(16));\n      hexChars.push((bite & 0x0f).toString(16));\n    }\n\n    return hexChars.join('');\n  },\n\n  /**\n   * Converts a hex string to a word array.\n   *\n   * @param {string} hexStr The hex string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n   */\n  parse(hexStr) {\n    // Shortcut\n    const hexStrLength = hexStr.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < hexStrLength; i += 2) {\n      words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n    }\n\n    return new WordArray(words, hexStrLength / 2);\n  },\n};\n\n/**\n * Latin1 encoding strategy.\n */\nexport const Latin1 = {\n  /**\n   * Converts a word array to a Latin1 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Latin1 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n\n    // Convert\n    const latin1Chars = [];\n    for (let i = 0; i < sigBytes; i += 1) {\n      const bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      latin1Chars.push(String.fromCharCode(bite));\n    }\n\n    return latin1Chars.join('');\n  },\n\n  /**\n   * Converts a Latin1 string to a word array.\n   *\n   * @param {string} latin1Str The Latin1 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n   */\n  parse(latin1Str) {\n    // Shortcut\n    const latin1StrLength = latin1Str.length;\n\n    // Convert\n    const words = [];\n    for (let i = 0; i < latin1StrLength; i += 1) {\n      words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n    }\n\n    return new WordArray(words, latin1StrLength);\n  },\n};\n\n/**\n * UTF-8 encoding strategy.\n */\nexport const Utf8 = {\n  /**\n   * Converts a word array to a UTF-8 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The UTF-8 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    try {\n      return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n    } catch (e) {\n      throw new Error('Malformed UTF-8 data');\n    }\n  },\n\n  /**\n   * Converts a UTF-8 string to a word array.\n   *\n   * @param {string} utf8Str The UTF-8 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n   */\n  parse(utf8Str) {\n    return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n  },\n};\n\n/**\n * Abstract buffered block algorithm template.\n *\n * The property blockSize must be implemented in a concrete subtype.\n *\n * @property {number} _minBufferSize\n *\n *     The number of blocks that should be kept unprocessed in the buffer. Default: 0\n */\nexport class BufferedBlockAlgorithm extends Base {\n  constructor() {\n    super();\n    this._minBufferSize = 0;\n  }\n\n  /**\n   * Resets this block algorithm's data buffer to its initial state.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm.reset();\n   */\n  reset() {\n    // Initial values\n    this._data = new WordArray();\n    this._nDataBytes = 0;\n  }\n\n  /**\n   * Adds new data to this block algorithm's buffer.\n   *\n   * @param {WordArray|string} data\n   *\n   *     The data to append. Strings are converted to a WordArray using UTF-8.\n   *\n   * @example\n   *\n   *     bufferedBlockAlgorithm._append('data');\n   *     bufferedBlockAlgorithm._append(wordArray);\n   */\n  _append(data) {\n    let m_data = data;\n\n    // Convert string to WordArray, else assume WordArray already\n    if (typeof m_data === 'string') {\n      m_data = Utf8.parse(m_data);\n    }\n\n    // Append\n    this._data.concat(m_data);\n    this._nDataBytes += m_data.sigBytes;\n  }\n\n  /**\n   * Processes available data blocks.\n   *\n   * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n   *\n   * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n   *\n   * @return {WordArray} The processed data.\n   *\n   * @example\n   *\n   *     var processedData = bufferedBlockAlgorithm._process();\n   *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n   */\n  _process(doFlush) {\n    let processedWords;\n\n    // Shortcuts\n    const { _data: data, blockSize } = this;\n    const dataWords = data.words;\n    const dataSigBytes = data.sigBytes;\n    const blockSizeBytes = blockSize * 4;\n\n    // Count blocks ready\n    let nBlocksReady = dataSigBytes / blockSizeBytes;\n    if (doFlush) {\n      // Round up to include partial blocks\n      nBlocksReady = Math.ceil(nBlocksReady);\n    } else {\n      // Round down to include only full blocks,\n      // less the number of blocks that must remain in the buffer\n      nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n    }\n\n    // Count words ready\n    const nWordsReady = nBlocksReady * blockSize;\n\n    // Count bytes ready\n    const nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n    // Process blocks\n    if (nWordsReady) {\n      for (let offset = 0; offset < nWordsReady; offset += blockSize) {\n        // Perform concrete-algorithm logic\n        this._doProcessBlock(dataWords, offset);\n      }\n\n      // Remove processed words\n      processedWords = dataWords.splice(0, nWordsReady);\n      data.sigBytes -= nBytesReady;\n    }\n\n    // Return processed words\n    return new WordArray(processedWords, nBytesReady);\n  }\n\n  /**\n   * Creates a copy of this object.\n   *\n   * @return {Object} The clone.\n   *\n   * @example\n   *\n   *     var clone = bufferedBlockAlgorithm.clone();\n   */\n  clone() {\n    const clone = super.clone.call(this);\n    clone._data = this._data.clone();\n\n    return clone;\n  }\n}\n\n/**\n * Abstract hasher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n */\nexport class Hasher extends BufferedBlockAlgorithm {\n  constructor(cfg) {\n    super();\n\n    this.blockSize = 512 / 32;\n\n    /**\n     * Configuration options.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates a shortcut function to a hasher's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to create a helper for.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHelper(SubHasher) {\n    return (message, cfg) => new SubHasher(cfg).finalize(message);\n  }\n\n  /**\n   * Creates a shortcut function to the HMAC's object interface.\n   *\n   * @param {Hasher} SubHasher The hasher to use in this HMAC helper.\n   *\n   * @return {Function} The shortcut function.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n   */\n  static _createHmacHelper(SubHasher) {\n    return (message, key) => new HMAC(SubHasher, key).finalize(message);\n  }\n\n  /**\n   * Resets this hasher to its initial state.\n   *\n   * @example\n   *\n   *     hasher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-hasher logic\n    this._doReset();\n  }\n\n  /**\n   * Updates this hasher with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {Hasher} This hasher.\n   *\n   * @example\n   *\n   *     hasher.update('message');\n   *     hasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    // Append\n    this._append(messageUpdate);\n\n    // Update the hash\n    this._process();\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the hash computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The hash.\n   *\n   * @example\n   *\n   *     var hash = hasher.finalize();\n   *     var hash = hasher.finalize('message');\n   *     var hash = hasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Final message update\n    if (messageUpdate) {\n      this._append(messageUpdate);\n    }\n\n    // Perform concrete-hasher logic\n    const hash = this._doFinalize();\n\n    return hash;\n  }\n}\n\n/**\n * HMAC algorithm.\n */\nexport class HMAC extends Base {\n  /**\n   * Initializes a newly created HMAC.\n   *\n   * @param {Hasher} SubHasher The hash algorithm to use.\n   * @param {WordArray|string} key The secret key.\n   *\n   * @example\n   *\n   *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n   */\n  constructor(SubHasher, key) {\n    super();\n\n    const hasher = new SubHasher();\n    this._hasher = hasher;\n\n    // Convert string to WordArray, else assume WordArray already\n    let _key = key;\n    if (typeof _key === 'string') {\n      _key = Utf8.parse(_key);\n    }\n\n    // Shortcuts\n    const hasherBlockSize = hasher.blockSize;\n    const hasherBlockSizeBytes = hasherBlockSize * 4;\n\n    // Allow arbitrary length keys\n    if (_key.sigBytes > hasherBlockSizeBytes) {\n      _key = hasher.finalize(key);\n    }\n\n    // Clamp excess bits\n    _key.clamp();\n\n    // Clone key for inner and outer pads\n    const oKey = _key.clone();\n    this._oKey = oKey;\n    const iKey = _key.clone();\n    this._iKey = iKey;\n\n    // Shortcuts\n    const oKeyWords = oKey.words;\n    const iKeyWords = iKey.words;\n\n    // XOR keys with pad constants\n    for (let i = 0; i < hasherBlockSize; i += 1) {\n      oKeyWords[i] ^= 0x5c5c5c5c;\n      iKeyWords[i] ^= 0x36363636;\n    }\n    oKey.sigBytes = hasherBlockSizeBytes;\n    iKey.sigBytes = hasherBlockSizeBytes;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Resets this HMAC to its initial state.\n   *\n   * @example\n   *\n   *     hmacHasher.reset();\n   */\n  reset() {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Reset\n    hasher.reset();\n    hasher.update(this._iKey);\n  }\n\n  /**\n   * Updates this HMAC with a message.\n   *\n   * @param {WordArray|string} messageUpdate The message to append.\n   *\n   * @return {HMAC} This HMAC instance.\n   *\n   * @example\n   *\n   *     hmacHasher.update('message');\n   *     hmacHasher.update(wordArray);\n   */\n  update(messageUpdate) {\n    this._hasher.update(messageUpdate);\n\n    // Chainable\n    return this;\n  }\n\n  /**\n   * Finalizes the HMAC computation.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} messageUpdate (Optional) A final message update.\n   *\n   * @return {WordArray} The HMAC.\n   *\n   * @example\n   *\n   *     var hmac = hmacHasher.finalize();\n   *     var hmac = hmacHasher.finalize('message');\n   *     var hmac = hmacHasher.finalize(wordArray);\n   */\n  finalize(messageUpdate) {\n    // Shortcut\n    const hasher = this._hasher;\n\n    // Compute HMAC\n    const innerHash = hasher.finalize(messageUpdate);\n    hasher.reset();\n    const hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n    return hmac;\n  }\n}\n","import {\n  WordArray,\n} from './core.js';\n\nconst parseLoop = (base64Str, base64StrLength, reverseMap) => {\n  const words = [];\n  let nBytes = 0;\n  for (let i = 0; i < base64StrLength; i += 1) {\n    if (i % 4) {\n      const bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n      const bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n      const bitsCombined = bits1 | bits2;\n      words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n      nBytes += 1;\n    }\n  }\n  return WordArray.create(words, nBytes);\n};\n\n/**\n * Base64 encoding strategy.\n */\nexport const Base64 = {\n  /**\n   * Converts a word array to a Base64 string.\n   *\n   * @param {WordArray} wordArray The word array.\n   *\n   * @return {string} The Base64 string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const base64String = CryptoJS.enc.Base64.stringify(wordArray);\n   */\n  stringify(wordArray) {\n    // Shortcuts\n    const { words, sigBytes } = wordArray;\n    const map = this._map;\n\n    // Clamp excess bits\n    wordArray.clamp();\n\n    // Convert\n    const base64Chars = [];\n    for (let i = 0; i < sigBytes; i += 3) {\n      const byte1 = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n      const byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n      const byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n      const triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n      for (let j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j += 1) {\n        base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n      }\n    }\n\n    // Add padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      while (base64Chars.length % 4) {\n        base64Chars.push(paddingChar);\n      }\n    }\n\n    return base64Chars.join('');\n  },\n\n  /**\n   * Converts a Base64 string to a word array.\n   *\n   * @param {string} base64Str The Base64 string.\n   *\n   * @return {WordArray} The word array.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const wordArray = CryptoJS.enc.Base64.parse(base64String);\n   */\n  parse(base64Str) {\n    // Shortcuts\n    let base64StrLength = base64Str.length;\n    const map = this._map;\n    let reverseMap = this._reverseMap;\n\n    if (!reverseMap) {\n      this._reverseMap = [];\n      reverseMap = this._reverseMap;\n      for (let j = 0; j < map.length; j += 1) {\n        reverseMap[map.charCodeAt(j)] = j;\n      }\n    }\n\n    // Ignore padding\n    const paddingChar = map.charAt(64);\n    if (paddingChar) {\n      const paddingIndex = base64Str.indexOf(paddingChar);\n      if (paddingIndex !== -1) {\n        base64StrLength = paddingIndex;\n      }\n    }\n\n    // Convert\n    return parseLoop(base64Str, base64StrLength, reverseMap);\n  },\n\n  _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=',\n};\n","import {\n  Base,\n  WordArray,\n} from './core.js';\nimport { MD5Algo } from './md5.js';\n\n/**\n * This key derivation function is meant to conform with EVP_BytesToKey.\n * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n */\nexport class EvpKDFAlgo extends Base {\n  /**\n   * Initializes a newly created key derivation function.\n   *\n   * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n   *\n   * @example\n   *\n   *     const kdf = CryptoJS.algo.EvpKDF.create();\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n   *     const kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n   */\n  constructor(cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n     * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n     * @property {number} iterations The number of iterations to perform. Default: 1\n     */\n    this.cfg = Object.assign(\n      new Base(),\n      {\n        keySize: 128 / 32,\n        hasher: MD5Algo,\n        iterations: 1,\n      },\n      cfg,\n    );\n  }\n\n  /**\n   * Derives a key from a password.\n   *\n   * @param {WordArray|string} password The password.\n   * @param {WordArray|string} salt A salt.\n   *\n   * @return {WordArray} The derived key.\n   *\n   * @example\n   *\n   *     const key = kdf.compute(password, salt);\n   */\n  compute(password, salt) {\n    let block;\n\n    // Shortcut\n    const { cfg } = this;\n\n    // Init hasher\n    const hasher = cfg.hasher.create();\n\n    // Initial values\n    const derivedKey = WordArray.create();\n\n    // Shortcuts\n    const derivedKeyWords = derivedKey.words;\n    const { keySize, iterations } = cfg;\n\n    // Generate key\n    while (derivedKeyWords.length < keySize) {\n      if (block) {\n        hasher.update(block);\n      }\n      block = hasher.update(password).finalize(salt);\n      hasher.reset();\n\n      // Iterations\n      for (let i = 1; i < iterations; i += 1) {\n        block = hasher.finalize(block);\n        hasher.reset();\n      }\n\n      derivedKey.concat(block);\n    }\n    derivedKey.sigBytes = keySize * 4;\n\n    return derivedKey;\n  }\n}\n\n/**\n * Derives a key from a password.\n *\n * @param {WordArray|string} password The password.\n * @param {WordArray|string} salt A salt.\n * @param {Object} cfg (Optional) The configuration options to use for this computation.\n *\n * @return {WordArray} The derived key.\n *\n * @static\n *\n * @example\n *\n *     var key = CryptoJS.EvpKDF(password, salt);\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n */\nexport const EvpKDF = (password, salt, cfg) => EvpKDFAlgo.create(cfg).compute(password, salt);\n","/* eslint-disable no-use-before-define */\n\nimport {\n  Base,\n  WordArray,\n  BufferedBlockAlgorithm,\n} from './core.js';\nimport { Base64 } from './enc-base64.js';\nimport { EvpKDFAlgo } from './evpkdf.js';\n\n/**\n * Abstract base cipher template.\n *\n * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n */\nexport class Cipher extends BufferedBlockAlgorithm {\n  /**\n   * Initializes a newly created cipher.\n   *\n   * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.create(\n   *       CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray }\n   *     );\n   */\n  constructor(xformMode, key, cfg) {\n    super();\n\n    /**\n     * Configuration options.\n     *\n     * @property {WordArray} iv The IV to use for this operation.\n     */\n    this.cfg = Object.assign(new Base(), cfg);\n\n    // Store transform mode and key\n    this._xformMode = xformMode;\n    this._key = key;\n\n    // Set initial values\n    this.reset();\n  }\n\n  /**\n   * Creates this cipher in encryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createEncryptor(key, cfg) {\n    return this.create(this._ENC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates this cipher in decryption mode.\n   *\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {Cipher} A cipher instance.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n   */\n  static createDecryptor(key, cfg) {\n    return this.create(this._DEC_XFORM_MODE, key, cfg);\n  }\n\n  /**\n   * Creates shortcut functions to a cipher's object interface.\n   *\n   * @param {Cipher} cipher The cipher to create a helper for.\n   *\n   * @return {Object} An object with encrypt and decrypt shortcut functions.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n   */\n  static _createHelper(SubCipher) {\n    const selectCipherStrategy = (key) => {\n      if (typeof key === 'string') {\n        return PasswordBasedCipher;\n      }\n      return SerializableCipher;\n    };\n\n    return {\n      encrypt(message, key, cfg) {\n        return selectCipherStrategy(key).encrypt(SubCipher, message, key, cfg);\n      },\n\n      decrypt(ciphertext, key, cfg) {\n        return selectCipherStrategy(key).decrypt(SubCipher, ciphertext, key, cfg);\n      },\n    };\n  }\n\n  /**\n   * Resets this cipher to its initial state.\n   *\n   * @example\n   *\n   *     cipher.reset();\n   */\n  reset() {\n    // Reset data buffer\n    super.reset.call(this);\n\n    // Perform concrete-cipher logic\n    this._doReset();\n  }\n\n  /**\n   * Adds data to be encrypted or decrypted.\n   *\n   * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.process('data');\n   *     const encrypted = cipher.process(wordArray);\n   */\n  process(dataUpdate) {\n    // Append\n    this._append(dataUpdate);\n\n    // Process available blocks\n    return this._process();\n  }\n\n  /**\n   * Finalizes the encryption or decryption process.\n   * Note that the finalize operation is effectively a destructive, read-once operation.\n   *\n   * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n   *\n   * @return {WordArray} The data after final processing.\n   *\n   * @example\n   *\n   *     const encrypted = cipher.finalize();\n   *     const encrypted = cipher.finalize('data');\n   *     const encrypted = cipher.finalize(wordArray);\n   */\n  finalize(dataUpdate) {\n    // Final data update\n    if (dataUpdate) {\n      this._append(dataUpdate);\n    }\n\n    // Perform concrete-cipher logic\n    const finalProcessedData = this._doFinalize();\n\n    return finalProcessedData;\n  }\n}\nCipher._ENC_XFORM_MODE = 1;\nCipher._DEC_XFORM_MODE = 2;\nCipher.keySize = 128 / 32;\nCipher.ivSize = 128 / 32;\n\n/**\n * Abstract base stream cipher template.\n *\n * @property {number} blockSize\n *\n *     The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n */\nexport class StreamCipher extends Cipher {\n  constructor(...args) {\n    super(...args);\n\n    this.blockSize = 1;\n  }\n\n  _doFinalize() {\n    // Process partial blocks\n    const finalProcessedBlocks = this._process(!!'flush');\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * Abstract base block cipher mode template.\n */\nexport class BlockCipherMode extends Base {\n  /**\n   * Initializes a newly created mode.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n   */\n  constructor(cipher, iv) {\n    super();\n\n    this._cipher = cipher;\n    this._iv = iv;\n  }\n\n  /**\n   * Creates this mode for encryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n   */\n  static createEncryptor(cipher, iv) {\n    return this.Encryptor.create(cipher, iv);\n  }\n\n  /**\n   * Creates this mode for decryption.\n   *\n   * @param {Cipher} cipher A block cipher instance.\n   * @param {Array} iv The IV words.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     const mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n   */\n  static createDecryptor(cipher, iv) {\n    return this.Decryptor.create(cipher, iv);\n  }\n}\n\nfunction xorBlock(words, offset, blockSize) {\n  const _words = words;\n  let block;\n\n  // Shortcut\n  const iv = this._iv;\n\n  // Choose mixing block\n  if (iv) {\n    block = iv;\n\n    // Remove IV for subsequent blocks\n    this._iv = undefined;\n  } else {\n    block = this._prevBlock;\n  }\n\n  // XOR blocks\n  for (let i = 0; i < blockSize; i += 1) {\n    _words[offset + i] ^= block[i];\n  }\n}\n\n/**\n * Cipher Block Chaining mode.\n */\n\n/**\n * Abstract base CBC mode.\n */\nexport class CBC extends BlockCipherMode {\n}\n/**\n * CBC encryptor.\n */\nCBC.Encryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // XOR and encrypt\n    xorBlock.call(this, words, offset, blockSize);\n    cipher.encryptBlock(words, offset);\n\n    // Remember this block to use with next block\n    this._prevBlock = words.slice(offset, offset + blockSize);\n  }\n};\n/**\n * CBC decryptor.\n */\nCBC.Decryptor = class extends CBC {\n  /**\n   * Processes the data block at offset.\n   *\n   * @param {Array} words The data words to operate on.\n   * @param {number} offset The offset where the block starts.\n   *\n   * @example\n   *\n   *     mode.processBlock(data.words, offset);\n   */\n  processBlock(words, offset) {\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n\n    // Remember this block to use with next block\n    const thisBlock = words.slice(offset, offset + blockSize);\n\n    // Decrypt and XOR\n    cipher.decryptBlock(words, offset);\n    xorBlock.call(this, words, offset, blockSize);\n\n    // This block becomes the previous block\n    this._prevBlock = thisBlock;\n  }\n};\n\n/**\n * PKCS #5/7 padding strategy.\n */\nexport const Pkcs7 = {\n  /**\n   * Pads data using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to pad.\n   * @param {number} blockSize The multiple that the data should be padded to.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n   */\n  pad(data, blockSize) {\n    // Shortcut\n    const blockSizeBytes = blockSize * 4;\n\n    // Count padding bytes\n    const nPaddingBytes = blockSizeBytes - (data.sigBytes % blockSizeBytes);\n\n    // Create padding word\n    const paddingWord = (nPaddingBytes << 24)\n      | (nPaddingBytes << 16)\n      | (nPaddingBytes << 8)\n      | nPaddingBytes;\n\n    // Create padding\n    const paddingWords = [];\n    for (let i = 0; i < nPaddingBytes; i += 4) {\n      paddingWords.push(paddingWord);\n    }\n    const padding = WordArray.create(paddingWords, nPaddingBytes);\n\n    // Add padding\n    data.concat(padding);\n  },\n\n  /**\n   * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n   *\n   * @param {WordArray} data The data to unpad.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n   */\n  unpad(data) {\n    const _data = data;\n\n    // Get number of padding bytes from last byte\n    const nPaddingBytes = _data.words[(_data.sigBytes - 1) >>> 2] & 0xff;\n\n    // Remove padding\n    _data.sigBytes -= nPaddingBytes;\n  },\n};\n\n/**\n * Abstract base block cipher template.\n *\n * @property {number} blockSize\n *\n *    The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n */\nexport class BlockCipher extends Cipher {\n  constructor(xformMode, key, cfg) {\n    /**\n     * Configuration options.\n     *\n     * @property {Mode} mode The block mode to use. Default: CBC\n     * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n     */\n    super(xformMode, key, Object.assign(\n      {\n        mode: CBC,\n        padding: Pkcs7,\n      },\n      cfg,\n    ));\n\n    this.blockSize = 128 / 32;\n  }\n\n  reset() {\n    let modeCreator;\n\n    // Reset cipher\n    super.reset.call(this);\n\n    // Shortcuts\n    const { cfg } = this;\n    const { iv, mode } = cfg;\n\n    // Reset block mode\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      modeCreator = mode.createEncryptor;\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      modeCreator = mode.createDecryptor;\n      // Keep at least one block in the buffer for unpadding\n      this._minBufferSize = 1;\n    }\n\n    this._mode = modeCreator.call(mode, this, iv && iv.words);\n    this._mode.__creator = modeCreator;\n  }\n\n  _doProcessBlock(words, offset) {\n    this._mode.processBlock(words, offset);\n  }\n\n  _doFinalize() {\n    let finalProcessedBlocks;\n\n    // Shortcut\n    const { padding } = this.cfg;\n\n    // Finalize\n    if (this._xformMode === this.constructor._ENC_XFORM_MODE) {\n      // Pad data\n      padding.pad(this._data, this.blockSize);\n\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n    } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n      // Process final blocks\n      finalProcessedBlocks = this._process(!!'flush');\n\n      // Unpad data\n      padding.unpad(finalProcessedBlocks);\n    }\n\n    return finalProcessedBlocks;\n  }\n}\n\n/**\n * A collection of cipher parameters.\n *\n * @property {WordArray} ciphertext The raw ciphertext.\n * @property {WordArray} key The key to this ciphertext.\n * @property {WordArray} iv The IV used in the ciphering operation.\n * @property {WordArray} salt The salt used with a key derivation function.\n * @property {Cipher} algorithm The cipher algorithm.\n * @property {Mode} mode The block mode used in the ciphering operation.\n * @property {Padding} padding The padding scheme used in the ciphering operation.\n * @property {number} blockSize The block size of the cipher.\n * @property {Format} formatter\n *    The default formatting strategy to convert this cipher params object to a string.\n */\nexport class CipherParams extends Base {\n  /**\n   * Initializes a newly created cipher params object.\n   *\n   * @param {Object} cipherParams An object with any of the possible cipher parameters.\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.lib.CipherParams.create({\n   *         ciphertext: ciphertextWordArray,\n   *         key: keyWordArray,\n   *         iv: ivWordArray,\n   *         salt: saltWordArray,\n   *         algorithm: CryptoJS.algo.AES,\n   *         mode: CryptoJS.mode.CBC,\n   *         padding: CryptoJS.pad.PKCS7,\n   *         blockSize: 4,\n   *         formatter: CryptoJS.format.OpenSSL\n   *     });\n   */\n  constructor(cipherParams) {\n    super();\n\n    this.mixIn(cipherParams);\n  }\n\n  /**\n   * Converts this cipher params object to a string.\n   *\n   * @param {Format} formatter (Optional) The formatting strategy to use.\n   *\n   * @return {string} The stringified cipher params.\n   *\n   * @throws Error If neither the formatter nor the default formatter is set.\n   *\n   * @example\n   *\n   *     var string = cipherParams + '';\n   *     var string = cipherParams.toString();\n   *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n   */\n  toString(formatter) {\n    return (formatter || this.formatter).stringify(this);\n  }\n}\n\n/**\n * OpenSSL formatting strategy.\n */\nexport const OpenSSLFormatter = {\n  /**\n   * Converts a cipher params object to an OpenSSL-compatible string.\n   *\n   * @param {CipherParams} cipherParams The cipher params object.\n   *\n   * @return {string} The OpenSSL-compatible string.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n   */\n  stringify(cipherParams) {\n    let wordArray;\n\n    // Shortcuts\n    const { ciphertext, salt } = cipherParams;\n\n    // Format\n    if (salt) {\n      wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n    } else {\n      wordArray = ciphertext;\n    }\n\n    return wordArray.toString(Base64);\n  },\n\n  /**\n   * Converts an OpenSSL-compatible string to a cipher params object.\n   *\n   * @param {string} openSSLStr The OpenSSL-compatible string.\n   *\n   * @return {CipherParams} The cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n   */\n  parse(openSSLStr) {\n    let salt;\n\n    // Parse base64\n    const ciphertext = Base64.parse(openSSLStr);\n\n    // Shortcut\n    const ciphertextWords = ciphertext.words;\n\n    // Test for salt\n    if (ciphertextWords[0] === 0x53616c74 && ciphertextWords[1] === 0x65645f5f) {\n      // Extract salt\n      salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n      // Remove salt from ciphertext\n      ciphertextWords.splice(0, 4);\n      ciphertext.sigBytes -= 16;\n    }\n\n    return CipherParams.create({ ciphertext, salt });\n  },\n};\n\n/**\n * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n */\nexport class SerializableCipher extends Base {\n  /**\n   * Encrypts a message.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key);\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       .encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, key, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Encrypt\n    const encryptor = cipher.createEncryptor(key, _cfg);\n    const ciphertext = encryptor.finalize(message);\n\n    // Shortcut\n    const cipherCfg = encryptor.cfg;\n\n    // Create and return serializable cipher params\n    return CipherParams.create({\n      ciphertext,\n      key,\n      iv: cipherCfg.iv,\n      algorithm: cipher,\n      mode: cipherCfg.mode,\n      padding: cipherCfg.padding,\n      blockSize: encryptor.blockSize,\n      formatter: _cfg.format,\n    });\n  }\n\n  /**\n   * Decrypts serialized ciphertext.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {WordArray} key The key.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.SerializableCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, key,\n   *         { iv: iv, format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, key, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Decrypt\n    const plaintext = cipher.createDecryptor(key, _cfg).finalize(_ciphertext.ciphertext);\n\n    return plaintext;\n  }\n\n  /**\n   * Converts serialized ciphertext to CipherParams,\n   * else assumed CipherParams already and returns ciphertext unchanged.\n   *\n   * @param {CipherParams|string} ciphertext The ciphertext.\n   * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n   *\n   * @return {CipherParams} The unserialized ciphertext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.SerializableCipher\n   *       ._parse(ciphertextStringOrParams, format);\n   */\n  static _parse(ciphertext, format) {\n    if (typeof ciphertext === 'string') {\n      return format.parse(ciphertext, this);\n    }\n    return ciphertext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {Formatter} format\n *\n *    The formatting strategy to convert cipher param objects to and from a string.\n *    Default: OpenSSL\n */\nSerializableCipher.cfg = Object.assign(\n  new Base(),\n  { format: OpenSSLFormatter },\n);\n\n/**\n * OpenSSL key derivation function.\n */\nexport const OpenSSLKdf = {\n  /**\n   * Derives a key and IV from a password.\n   *\n   * @param {string} password The password to derive from.\n   * @param {number} keySize The size in words of the key to generate.\n   * @param {number} ivSize The size in words of the IV to generate.\n   * @param {WordArray|string} salt\n   *     (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n   *\n   * @return {CipherParams} A cipher params object with the key, IV, and salt.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n   *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n   */\n  execute(password, keySize, ivSize, salt) {\n    let _salt = salt;\n\n    // Generate random salt\n    if (!_salt) {\n      _salt = WordArray.random(64 / 8);\n    }\n\n    // Derive key and IV\n    const key = EvpKDFAlgo.create({ keySize: keySize + ivSize }).compute(password, _salt);\n\n    // Separate key and IV\n    const iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n    key.sigBytes = keySize * 4;\n\n    // Return params\n    return CipherParams.create({ key, iv, salt: _salt });\n  },\n};\n\n/**\n * A serializable cipher wrapper that derives the key from a password,\n * and returns ciphertext as a serializable cipher params object.\n */\nexport class PasswordBasedCipher extends SerializableCipher {\n  /**\n   * Encrypts a message using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {WordArray|string} message The message to encrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {CipherParams} A cipher params object.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password');\n   *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher\n   *       .encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n   */\n  static encrypt(cipher, message, password, cfg) {\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Encrypt\n    const ciphertext = SerializableCipher.encrypt\n      .call(this, cipher, message, derivedParams.key, _cfg);\n\n    // Mix in derived params\n    ciphertext.mixIn(derivedParams);\n\n    return ciphertext;\n  }\n\n  /**\n   * Decrypts serialized ciphertext using a password.\n   *\n   * @param {Cipher} cipher The cipher algorithm to use.\n   * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n   * @param {string} password The password.\n   * @param {Object} cfg (Optional) The configuration options to use for this operation.\n   *\n   * @return {WordArray} The plaintext.\n   *\n   * @static\n   *\n   * @example\n   *\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   *     var plaintext = CryptoJS.lib.PasswordBasedCipher\n   *       .decrypt(CryptoJS.algo.AES, ciphertextParams, 'password',\n   *         { format: CryptoJS.format.OpenSSL });\n   */\n  static decrypt(cipher, ciphertext, password, cfg) {\n    let _ciphertext = ciphertext;\n\n    // Apply config defaults\n    const _cfg = Object.assign(new Base(), this.cfg, cfg);\n\n    // Convert string to CipherParams\n    _ciphertext = this._parse(_ciphertext, _cfg.format);\n\n    // Derive key and other params\n    const derivedParams = _cfg.kdf\n      .execute(password, cipher.keySize, cipher.ivSize, _ciphertext.salt);\n\n    // Add IV to config\n    _cfg.iv = derivedParams.iv;\n\n    // Decrypt\n    const plaintext = SerializableCipher.decrypt\n      .call(this, cipher, _ciphertext, derivedParams.key, _cfg);\n\n    return plaintext;\n  }\n}\n/**\n * Configuration options.\n *\n * @property {KDF} kdf\n *     The key derivation function to use to generate a key and IV from a password.\n *     Default: OpenSSL\n */\nPasswordBasedCipher.cfg = Object.assign(SerializableCipher.cfg, { kdf: OpenSSLKdf });\n","import {\n  BlockCipher,\n} from './cipher-core.js';\n\n// Lookup tables\nconst _SBOX = [];\nconst INV_SBOX = [];\nconst _SUB_MIX_0 = [];\nconst _SUB_MIX_1 = [];\nconst _SUB_MIX_2 = [];\nconst _SUB_MIX_3 = [];\nconst INV_SUB_MIX_0 = [];\nconst INV_SUB_MIX_1 = [];\nconst INV_SUB_MIX_2 = [];\nconst INV_SUB_MIX_3 = [];\n\n// Compute lookup tables\n\n// Compute double table\nconst d = [];\nfor (let i = 0; i < 256; i += 1) {\n  if (i < 128) {\n    d[i] = i << 1;\n  } else {\n    d[i] = (i << 1) ^ 0x11b;\n  }\n}\n\n// Walk GF(2^8)\nlet x = 0;\nlet xi = 0;\nfor (let i = 0; i < 256; i += 1) {\n  // Compute sbox\n  let sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n  sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n  _SBOX[x] = sx;\n  INV_SBOX[sx] = x;\n\n  // Compute multiplication\n  const x2 = d[x];\n  const x4 = d[x2];\n  const x8 = d[x4];\n\n  // Compute sub bytes, mix columns tables\n  let t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n  _SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n  _SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n  _SUB_MIX_2[x] = (t << 8) | (t >>> 24);\n  _SUB_MIX_3[x] = t;\n\n  // Compute inv sub bytes, inv mix columns tables\n  t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n  INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n  INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n  INV_SUB_MIX_2[sx] = (t << 8) | (t >>> 24);\n  INV_SUB_MIX_3[sx] = t;\n\n  // Compute next counter\n  if (!x) {\n    xi = 1;\n    x = xi;\n  } else {\n    x = x2 ^ d[d[d[x8 ^ x2]]];\n    xi ^= d[d[xi]];\n  }\n}\n\n// Precomputed Rcon lookup\nconst RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n/**\n * AES block cipher algorithm.\n */\nexport class AESAlgo extends BlockCipher {\n  _doReset() {\n    let t;\n\n    // Skip reset of nRounds has been set before and key did not change\n    if (this._nRounds && this._keyPriorReset === this._key) {\n      return;\n    }\n\n    // Shortcuts\n    this._keyPriorReset = this._key;\n    const key = this._keyPriorReset;\n    const keyWords = key.words;\n    const keySize = key.sigBytes / 4;\n\n    // Compute number of rounds\n    this._nRounds = keySize + 6;\n    const nRounds = this._nRounds;\n\n    // Compute number of key schedule rows\n    const ksRows = (nRounds + 1) * 4;\n\n    // Compute key schedule\n    this._keySchedule = [];\n    const keySchedule = this._keySchedule;\n    for (let ksRow = 0; ksRow < ksRows; ksRow += 1) {\n      if (ksRow < keySize) {\n        keySchedule[ksRow] = keyWords[ksRow];\n      } else {\n        t = keySchedule[ksRow - 1];\n\n        if (!(ksRow % keySize)) {\n          // Rot word\n          t = (t << 8) | (t >>> 24);\n\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n\n          // Mix Rcon\n          t ^= RCON[(ksRow / keySize) | 0] << 24;\n        } else if (keySize > 6 && ksRow % keySize === 4) {\n          // Sub word\n          t = (_SBOX[t >>> 24] << 24)\n            | (_SBOX[(t >>> 16) & 0xff] << 16)\n            | (_SBOX[(t >>> 8) & 0xff] << 8)\n            | _SBOX[t & 0xff];\n        }\n\n        keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n      }\n    }\n\n    // Compute inv key schedule\n    this._invKeySchedule = [];\n    const invKeySchedule = this._invKeySchedule;\n    for (let invKsRow = 0; invKsRow < ksRows; invKsRow += 1) {\n      const ksRow = ksRows - invKsRow;\n\n      if (invKsRow % 4) {\n        t = keySchedule[ksRow];\n      } else {\n        t = keySchedule[ksRow - 4];\n      }\n\n      if (invKsRow < 4 || ksRow <= 4) {\n        invKeySchedule[invKsRow] = t;\n      } else {\n        invKeySchedule[invKsRow] = INV_SUB_MIX_0[_SBOX[t >>> 24]]\n          ^ INV_SUB_MIX_1[_SBOX[(t >>> 16) & 0xff]]\n          ^ INV_SUB_MIX_2[_SBOX[(t >>> 8) & 0xff]]\n          ^ INV_SUB_MIX_3[_SBOX[t & 0xff]];\n      }\n    }\n  }\n\n  encryptBlock(M, offset) {\n    this._doCryptBlock(\n      M, offset, this._keySchedule, _SUB_MIX_0, _SUB_MIX_1, _SUB_MIX_2, _SUB_MIX_3, _SBOX,\n    );\n  }\n\n  decryptBlock(M, offset) {\n    const _M = M;\n\n    // Swap 2nd and 4th rows\n    let t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n\n    this._doCryptBlock(\n      _M,\n      offset,\n      this._invKeySchedule,\n      INV_SUB_MIX_0,\n      INV_SUB_MIX_1,\n      INV_SUB_MIX_2,\n      INV_SUB_MIX_3,\n      INV_SBOX,\n    );\n\n    // Inv swap 2nd and 4th rows\n    t = _M[offset + 1];\n    _M[offset + 1] = _M[offset + 3];\n    _M[offset + 3] = t;\n  }\n\n  _doCryptBlock(M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n    const _M = M;\n\n    // Shortcut\n    const nRounds = this._nRounds;\n\n    // Get input, add round key\n    let s0 = _M[offset] ^ keySchedule[0];\n    let s1 = _M[offset + 1] ^ keySchedule[1];\n    let s2 = _M[offset + 2] ^ keySchedule[2];\n    let s3 = _M[offset + 3] ^ keySchedule[3];\n\n    // Key schedule row counter\n    let ksRow = 4;\n\n    // Rounds\n    for (let round = 1; round < nRounds; round += 1) {\n      // Shift rows, sub bytes, mix columns, add round key\n      const t0 = SUB_MIX_0[s0 >>> 24]\n        ^ SUB_MIX_1[(s1 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s2 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s3 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t1 = SUB_MIX_0[s1 >>> 24]\n        ^ SUB_MIX_1[(s2 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s3 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s0 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t2 = SUB_MIX_0[s2 >>> 24]\n        ^ SUB_MIX_1[(s3 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s0 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s1 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n      const t3 = SUB_MIX_0[s3 >>> 24]\n        ^ SUB_MIX_1[(s0 >>> 16) & 0xff]\n        ^ SUB_MIX_2[(s1 >>> 8) & 0xff]\n        ^ SUB_MIX_3[s2 & 0xff]\n        ^ keySchedule[ksRow];\n      ksRow += 1;\n\n      // Update state\n      s0 = t0;\n      s1 = t1;\n      s2 = t2;\n      s3 = t3;\n    }\n\n    // Shift rows, sub bytes, add round key\n    const t0 = (\n      (SBOX[s0 >>> 24] << 24)\n        | (SBOX[(s1 >>> 16) & 0xff] << 16)\n        | (SBOX[(s2 >>> 8) & 0xff] << 8)\n        | SBOX[s3 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t1 = (\n      (SBOX[s1 >>> 24] << 24)\n        | (SBOX[(s2 >>> 16) & 0xff] << 16)\n        | (SBOX[(s3 >>> 8) & 0xff] << 8)\n        | SBOX[s0 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t2 = (\n      (SBOX[s2 >>> 24] << 24)\n        | (SBOX[(s3 >>> 16) & 0xff] << 16)\n        | (SBOX[(s0 >>> 8) & 0xff] << 8)\n        | SBOX[s1 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n    const t3 = (\n      (SBOX[s3 >>> 24] << 24)\n        | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]\n    ) ^ keySchedule[ksRow];\n    ksRow += 1;\n\n    // Set output\n    _M[offset] = t0;\n    _M[offset + 1] = t1;\n    _M[offset + 2] = t2;\n    _M[offset + 3] = t3;\n  }\n}\nAESAlgo.keySize = 256 / 32;\n\n/**\n * Shortcut functions to the cipher's object interface.\n *\n * @example\n *\n *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n */\nexport const AES = BlockCipher._createHelper(AESAlgo);\n","/**\n * Counter block mode.\n */\nimport {\n  BlockCipherMode,\n} from './cipher-core.js';\n\nexport class CTR extends BlockCipherMode {\n}\nCTR.Encryptor = class extends CTR {\n  processBlock(words, offset) {\n    const _words = words;\n\n    // Shortcuts\n    const cipher = this._cipher;\n    const { blockSize } = cipher;\n    const iv = this._iv;\n    let counter = this._counter;\n\n    // Generate keystream\n    if (iv) {\n      this._counter = iv.slice(0);\n      counter = this._counter;\n\n      // Remove IV for subsequent blocks\n      this._iv = undefined;\n    }\n    const keystream = counter.slice(0);\n    cipher.encryptBlock(keystream, 0);\n\n    // Increment counter\n    counter[blockSize - 1] = (counter[blockSize - 1] + 1) | 0;\n\n    // Encrypt\n    for (let i = 0; i < blockSize; i += 1) {\n      _words[offset + i] ^= keystream[i];\n    }\n  }\n};\nCTR.Decryptor = CTR.Encryptor;\n","/**\n * A noop padding strategy.\n */\nexport const NoPadding = {\n  pad() {\n  },\n\n  unpad() {\n  },\n};\n","import { WordArray, Hex } from 'crypto-es/lib/core'\nimport { CipherParams } from 'crypto-es/lib/cipher-core'\nimport { AES } from 'crypto-es/lib/aes'\nimport { CTR } from 'crypto-es/lib/mode-ctr'\nimport { NoPadding } from 'crypto-es/lib/pad-nopadding'\nimport { formatIV } from '../../utils'\nimport Buffer from '../buffer'\n\nconst Crypto = {\n\n  decryptWordArray: function (raw, key, iv) {\n    const realKey = Hex.parse(key)\n\n    const realIV = Hex.parse(formatIV(iv))\n    const message = WordArray.create(new Uint8Array(raw))\n    const decryptWord = AES.decrypt(\n      CipherParams.create({\n        ciphertext: message\n      }),\n      realKey,\n      {\n        iv: realIV,\n        mode: CTR,\n        padding: NoPadding\n      }\n    )\n    return Crypto.wordArrayToUint8Array(decryptWord)\n  },\n  wordArrayToUint8Array: function (wordArray) {\n    const l = wordArray.sigBytes\n    const words = wordArray.words\n    const result = new Uint8Array(l)\n    let i = 0\n    let j = 0\n    while (true) {\n      if (i === l) { break }\n      const w = words[j++]\n      result[i++] = (w & 0xff000000) >>> 24\n      if (i === l) { break }\n      result[i++] = (w & 0x00ff0000) >>> 16\n      if (i === l) { break }\n      result[i++] = (w & 0x0000ff00) >>> 8\n      if (i === l) { break }\n      result[i++] = (w & 0x000000ff)\n    }\n    return result\n  },\n\n  decoderAESCTRData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.videoSenc) {\n      const key = videoTrack.kidValue\n      const senc = videoTrack.videoSenc\n      videoTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        let encodeWord = item.data\n        const encodeBuffers = []\n        const decodeBuffers = []\n        const iv = sencBox.InitializationVector\n        if (sencBox.subsamples && sencBox.subsamples.length) {\n          sencBox.subsamples.forEach(function (value) {\n            const len = value.BytesOfClearData + value.BytesOfProtectedData\n            const sampleData = encodeWord.slice(0, len)\n            encodeBuffers.push(sampleData.slice(0, value.BytesOfClearData))\n            decodeBuffers.push(sampleData.slice(value.BytesOfClearData))\n            encodeWord = encodeWord.slice(len)\n          })\n        } else {\n          const len = item.size\n          encodeBuffers.push(encodeWord.slice(0, 0))\n          decodeBuffers.push(encodeWord.slice(0, len))\n          encodeWord = encodeWord.slice(len)\n        }\n        const tempBuffer = new Buffer()\n        tempBuffer.write(...decodeBuffers)\n        let decrypted = customDescryptHandler ? customDescryptHandler(tempBuffer.buffer, key, iv) : Crypto.decryptWordArray(tempBuffer.buffer, key, iv)\n        const buffer = new Buffer()\n        encodeBuffers.forEach((clearDataBuf, i) => {\n          const protectedDataLen = decodeBuffers[i].length\n          const decodeProtectedData = decrypted.slice(0, protectedDataLen)\n          buffer.write(clearDataBuf)\n          buffer.write(decodeProtectedData)\n          decrypted = decrypted.slice(protectedDataLen)\n        })\n        videoTrack.samples[index].data = buffer.buffer\n      })\n    }\n\n    if (audioTrack.audioSenc) {\n      const key = audioTrack.kidValue\n      const senc = audioTrack.audioSenc\n      audioTrack.samples.forEach((item, index) => {\n        const sencBox = senc[index]\n        const dec = customDescryptHandler ? customDescryptHandler(item.data, key, sencBox.InitializationVector) : Crypto.decryptWordArray(item.data, key, sencBox.InitializationVector)\n        audioTrack.samples[index].data = dec\n      })\n    }\n  }\n}\n\nexport default Crypto\n","import { VideoTrack, AudioTrack, MetadataTrack, AudioSample, VideoSample } from '../model'\nimport { readBig32 } from '../utils'\nimport { MP4Parser } from './mp4-parser'\nimport { Logger } from './logger'\nimport Crypto from './crypto/crypto'\nconst NEW_ARRAY_MAX_CNT = 20\nexport class MP4Demuxer {\n  _videoSamples = []\n  _audioSamples = []\n  _lastRemainBuffer = []\n  _lastRemainBufferStartPos = 0\n\n  constructor (videoSegmnents, audioSegmnents, metadataTrack, options) {\n    this.videoTrack = new VideoTrack()\n    this.audioTrack = new AudioTrack()\n    this.metadataTrack = metadataTrack || new MetadataTrack()\n    this.log = new Logger('MP4Demuxer', options && options.openLog ? !options.openLog : true)\n\n    videoSegmnents && videoSegmnents.forEach(item => {\n      this._videoSamples.push(...item.frames)\n    })\n    audioSegmnents && audioSegmnents.forEach(item => {\n      this._audioSamples.push(...item.frames)\n    })\n  }\n\n  parseSamples (moov) {\n    if (!moov) {\n      throw new Error('moov is required')\n    }\n    if (!this.videoTrack.codec && !this.audioTrack.codec) {\n      MP4Parser.moovToTrack(moov, this.videoTrack, this.audioTrack)\n      this.videoSenc = this.videoTrack.videoSenc\n      this.audioSenc = this.audioTrack.audioSenc\n    }\n    if (!this._audioSamples.length && !this._videoSamples.length) {\n      const ret = MP4Parser.moovToSamples(moov)\n      if (!ret) throw new Error('cannot parse samples from moov box')\n      this._videoSamples = ret.videoSamples || []\n      this._audioSamples = ret.audioSamples || []\n    }\n  }\n\n  demux (data, dataStart, videoIndexRange, audioIndexRange, moov) {\n    this.parseSamples(moov)\n\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    let sample\n    let sampleData\n    let startByte\n    if (videoIndexRange) {\n      let frame\n      let nalSize = 0\n      for (let i = videoIndexRange[0], l = videoIndexRange[1]; i <= l; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n        frame.duration = sample.duration\n        frame.gopId = sample.gopId\n        if (sample.keyframe) frame.setToKeyframe()\n        let start = 0\n        const len = sampleData.length - 1\n        while (start < len) {\n          nalSize = readBig32(sampleData, start)\n          start += 4\n          frame.units.push(sampleData.subarray(start, start + nalSize))\n          start += nalSize\n        }\n        videoTrack.samples.push(frame)\n      }\n\n      videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n    }\n    if (audioIndexRange) {\n      for (let i = audioIndexRange[0], l = audioIndexRange[1]; i <= l; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        startByte = sample.offset - dataStart\n        sampleData = data.subarray(startByte, startByte + sample.size)\n        audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration))\n      }\n      audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n    }\n\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  demuxPart (data, dataStart, videoIndexRange, audioIndexRange, moov, useEME, kidValue, customDescryptHandler) {\n    this.parseSamples(moov)\n\n    this.videoTrack.useEME = useEME\n    this.audioTrack.useEME = useEME\n    // this.log.debug('[demuxPart start],dataStart,', dataStart, ',dataLen,', data.byteLength, ', lastRemain,', this._lastRemainBuffer ? this._lastRemainBuffer.byteLength : 0)\n    if (this._lastRemainBuffer && this._lastRemainBuffer.byteLength > 0 && dataStart > this._lastRemainBufferStartPos && dataStart <= this._lastRemainBufferStartPos + this._lastRemainBuffer.byteLength) {\n      let tryCnt = 0\n      while (tryCnt < NEW_ARRAY_MAX_CNT) {\n        try {\n          const buffer = this._lastRemainBuffer.subarray(0, dataStart - this._lastRemainBufferStartPos)\n          const temp = new Uint8Array(data.byteLength + buffer.byteLength)\n          temp.set(buffer, 0)\n          temp.set(new Uint8Array(data), buffer.byteLength)\n          data = temp\n          dataStart -= buffer.byteLength\n          this._lastRemainBuffer = null\n          this._lastRemainBufferStartPos = 0\n          // this.log.debug('[demuxPart add lastRemain],dataStart,', dataStart, ',dataLen,', data.byteLength)\n          break\n        } catch (e) {\n          if (tryCnt < NEW_ARRAY_MAX_CNT) {\n            tryCnt++\n          } else {\n            throw new Error('new Uint8Array error:,' + e.errorMessage)\n          }\n        }\n      }\n    }\n    const videoTrack = this.videoTrack\n    const audioTrack = this.audioTrack\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n    videoTrack.videoSenc = null\n    audioTrack.audioSenc = null\n\n    let sample\n    let sampleData\n    let startByte\n    let videoEndByte = 0\n    let audioEndByte = 0\n    if (this._videoSamples.length > 0 && videoIndexRange.length > 0) {\n      let frame\n      const end = data.byteLength + dataStart\n      for (let i = videoIndexRange[0]; i <= videoIndexRange[1]; i++) {\n        sample = this._videoSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= end) {\n          startByte = sample.offset - dataStart\n          videoEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, videoEndByte)\n          frame = new VideoSample(sample.pts || sample.dts, sample.dts)\n          frame.duration = sample.duration\n          // this.log.debug('[video !!!!!!!!],frame,index，', sample.index, ',segmentIdx', segmentIdx, ', dataStart,', dataStart, ',dataEnd', end, ',Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts, ', keyframe', sample.keyframe)\n          frame.gopId = sample.gopId\n          frame.sampleOffset = sample.index\n          // frame.timeOffset = sample.timeOffset || sample.timeOffset === 0 ? sample.timeOffset : null\n          if (sample.keyframe) frame.setToKeyframe()\n          frame.data = sampleData\n          frame.size = sample.size\n          // this.log.debug('[demux video frame],frame,index，', sample.index, ', size,', sampleData.byteLength, ', hash ', hashVal(sampleData.toString()))\n          videoTrack.samples.push(frame)\n        }\n      }\n      if (videoTrack.samples.length > 0) {\n        videoTrack.gopId = videoTrack.samples[0].gopId\n        videoTrack.baseMediaDecodeTime = videoTrack.samples[0].dts\n        videoTrack.startPts = videoTrack.samples[0].pts / videoTrack.timescale\n        videoTrack.endPts = videoTrack.samples[videoTrack.samples.length - 1].pts / videoTrack.timescale\n        // this.log.debug('[demux video],frame,startPts，', videoTrack.startPts, ', endPts,', videoTrack.endPts)\n        if (this.videoSenc) {\n          videoTrack.videoSenc = this.videoSenc.slice(videoTrack.samples[0].sampleOffset, videoTrack.samples[0].sampleOffset + videoTrack.samples.length)\n          videoTrack.kidValue = kidValue\n        }\n      }\n    }\n    if (this._audioSamples.length > 0 && audioIndexRange.length > 0) {\n      for (let i = audioIndexRange[0]; i <= audioIndexRange[1]; i++) {\n        sample = this._audioSamples[i]\n        if (!sample) {\n          throw new Error(`cannot found video frame #${i}`)\n        }\n        if (sample.offset >= dataStart && sample.offset + sample.size <= data.byteLength + dataStart) {\n          startByte = sample.offset - dataStart\n          audioEndByte = startByte + sample.size\n          sampleData = data.subarray(startByte, audioEndByte)\n          // this.log.debug('[audio !!!!!!!!],audio frame,index，', sample.index, ',segmentIdx', segmentIdx, ', Samplestart,', sample.offset, ', SampleEnd,', sample.offset + sample.size, ',size,', sample.size, 'dts,', sample.dts, ',pts,', sample.pts || sample.dts)\n          // frame.gopId = sample.gopId\n          // this.log.debug('[demux audio frame],index ,', sample.index, ', size,', sampleData.byteLength, ', hash,', hashVal(sampleData.toString()))\n          audioTrack.samples.push(new AudioSample(sample.dts, sampleData, sample.duration, sample.index))\n        }\n      }\n      if (audioTrack.samples.length > 0) {\n        audioTrack.gopId = audioTrack.samples[0].gopId || videoTrack.gopId\n        audioTrack.baseMediaDecodeTime = audioTrack.samples[0].dts\n        audioTrack.startPts = audioTrack.samples[0].pts / audioTrack.timescale\n        audioTrack.endPts = audioTrack.samples[audioTrack.samples.length - 1].pts / audioTrack.timescale\n        // this.log.debug('[demux audio],frame,startPts，', audioTrack.startPts, ', endPts,', audioTrack.endPts)\n        if (this.audioSenc) {\n          audioTrack.audioSenc = this.audioSenc.slice(audioTrack.samples[0].sampleOffset, audioTrack.samples[0].sampleOffset + audioTrack.samples.length)\n          audioTrack.kidValue = kidValue\n        }\n      }\n    }\n    this.decoderData(videoTrack, audioTrack, customDescryptHandler)\n    let nalSize = 0\n    for (let i = 0; i < videoTrack.samples.length; i++) {\n      let start = 0\n      const sampleData = videoTrack.samples[i].data\n      const len = sampleData.length - 1\n      while (start < len) {\n        nalSize = readBig32(sampleData, start)\n        start += 4\n        videoTrack.samples[i].units.push(sampleData.subarray(start, start + nalSize))\n        start += nalSize\n      }\n    }\n    this._lastRemainBuffer = data.subarray(Math.max(videoEndByte, audioEndByte))\n    if (this._lastRemainBuffer.byteLength > 0) {\n      this._lastRemainBufferStartPos = dataStart + data.byteLength - this._lastRemainBuffer.byteLength\n    } else {\n      this._lastRemainBufferStartPos = 0\n    }\n    return {\n      videoTrack,\n      audioTrack,\n      metadataTrack: this.metadataTrack\n    }\n  }\n\n  reset () {\n    this._videoSamples = []\n    this._audioSamples = []\n    this._lastRemainBuffer = null\n    this._lastRemainBufferStartPos = 0\n    this.videoTrack.reset()\n    this.audioTrack.reset()\n    this.metadataTrack.reset()\n  }\n\n  decoderData (videoTrack, audioTrack, customDescryptHandler) {\n    if (videoTrack.useEME || audioTrack.useEME) return\n    Crypto.decoderAESCTRData(videoTrack, audioTrack, customDescryptHandler)\n  }\n\n  static probe (data) {\n    return MP4Parser.probe(data)\n  }\n}\n","import { TrackType } from '../model'\nimport { MP4 } from './mp4'\nimport { concatUint8Array } from '../utils'\n\nexport class MP4Remuxer {\n  /**\n   * @param {import('../model').VideoTrack} videoTrack\n   * @param {import('../model').AudioTrack} audioTrack\n   */\n  constructor (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack\n    this.audioTrack = audioTrack\n  }\n\n  /**\n   * @returns {import('./fmp4-remuxer').RemuxResult}\n   */\n  remux (videoTrack, audioTrack) {\n    this.videoTrack = videoTrack || this.videoTrack\n    this.audioTrack = audioTrack || this.audioTrack\n\n    const hasVideo = videoTrack?.exist() && videoTrack?.hasSample()\n    const hasAudio = audioTrack?.exist() && audioTrack?.hasSample()\n\n    let videoSegment\n    let audioSegment\n    if (hasVideo && hasAudio) {\n      videoSegment = this._remuxMix(videoTrack, audioTrack)\n    } else if (hasVideo) {\n      videoSegment = this._remuxTrack(videoTrack)\n    } else if (hasAudio) {\n      audioSegment = this._remuxTrack(audioTrack)\n    }\n\n    if (videoTrack) {\n      videoTrack.samples = []\n    }\n\n    if (audioTrack) {\n      audioTrack.samples = []\n    }\n\n    return {\n      videoSegment,\n      audioSegment\n    }\n  }\n\n  _remuxMix (videoTrack, audioTrack) {\n    const ftyp = MP4.ftyp([videoTrack, audioTrack])\n    const { mdatData: video, chunkOffset } = this._remuxData(videoTrack, ftyp.byteLength + 8)\n    const { mdatData: audio } = this._remuxData(audioTrack, chunkOffset)\n\n    const mdat = MP4.mdat(concatUint8Array(video, audio))\n    const moov = MP4.moovMP4([videoTrack, audioTrack])\n\n    videoTrack.ext = undefined\n    audioTrack.ext = undefined\n\n    videoTrack.samples = []\n    audioTrack.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxTrack (track) {\n    const ftyp = MP4.ftyp([track])\n\n    const { mdatData } = this._remuxData(track, ftyp.byteLength + 8)\n    const mdat = MP4.mdat(mdatData)\n    const moov = MP4.moovMP4([track])\n\n    track.ext = undefined\n    track.samples = []\n\n    return concatUint8Array(ftyp, mdat, moov)\n  }\n\n  _remuxData (track, chunkOffset) {\n    const isVideo = track.type === TrackType.VIDEO\n    const samples = track.samples\n\n    let mdatSize = 0\n    if (isVideo) {\n      samples.forEach((s) => {\n        mdatSize += s.units.reduce((t, c) => (t + c.byteLength), 0)\n        mdatSize += (s.units.length * 4)\n      })\n    } else {\n      mdatSize = samples.reduce((t, c) => (t + c.size), 0)\n    }\n\n    const mdatData = new Uint8Array(mdatSize)\n    const mdatView = new DataView(mdatData.buffer)\n\n    const ext = track.ext = {\n      stts: [],\n      stsc: [],\n      stsz: [],\n      stco: [],\n      stss: [],\n      ctts: []\n    }\n\n    const samplesPerChunk = 1\n    let dataOffset = 0\n    let totalDuration = 0\n    let sample\n    const sampleLen = samples.length\n    for (let i = 0; i < sampleLen; i++) {\n      sample = samples[i]\n      totalDuration += sample.duration\n\n      let sampleSize = isVideo ? 0 : sample.size\n      if (isVideo) {\n        sample.units.forEach((u) => {\n          mdatView.setUint32(dataOffset, u.byteLength)\n          dataOffset += 4\n          mdatData.set(u, dataOffset)\n          dataOffset += u.byteLength\n          sampleSize += (4 + u.byteLength)\n        })\n      } else {\n        mdatData.set(sample.data, dataOffset)\n        dataOffset += sampleSize\n      }\n      sample.size = sampleSize\n      ext.stsz.push(sampleSize)\n\n      if (isVideo) this._fillCttsSamples(ext.ctts, sample.cts)\n      this._fillSttsSamples(ext.stts, sample, samples[i + 1])\n      this._fillStcoSamples(ext.stco, i, samplesPerChunk, chunkOffset)\n      chunkOffset += sampleSize\n\n      if (isVideo && sample.keyframe) {\n        ext.stss.push(i + 1)\n      }\n    }\n\n    track.duration = totalDuration\n    this._fillStscSamples(ext.stsc, sampleLen, samplesPerChunk)\n\n    return {\n      mdatData,\n      chunkOffset\n    }\n  }\n\n  _fillSttsSamples (sttsSamples, cur, next) {\n    const lastSample = sttsSamples[sttsSamples.length - 1]\n\n    if (next) {\n      if (!lastSample || lastSample.value !== cur.duration) {\n        sttsSamples.push({ value: cur.duration, count: 1 })\n      } else {\n        lastSample.count++\n      }\n      return\n    }\n\n    if (lastSample) {\n      lastSample.count++\n    } else {\n      sttsSamples.push({ value: 40, count: 1 })\n    }\n  }\n\n  _fillCttsSamples (cttsSamples, cts) {\n    const lastSample = cttsSamples[cttsSamples.length - 1]\n\n    if (!lastSample || lastSample.value !== cts) {\n      cttsSamples.push({ value: cts, count: 1 })\n    } else {\n      lastSample.count++\n    }\n  }\n\n  _fillStcoSamples (stcoSamples, index, samplePerChunk, chunkOffset) {\n    if (!(index % samplePerChunk)) {\n      stcoSamples.push(chunkOffset)\n    }\n  }\n\n  _fillStscSamples (samples, sampleCount, samplesPerChunk) {\n    if (sampleCount <= samplesPerChunk) {\n      samples.push({ firstChunk: 1, samplesPerChunk: sampleCount, sampleDescIndex: 1 })\n    } else {\n      const len = Math.floor(sampleCount / samplesPerChunk)\n      const remaining = sampleCount % samplesPerChunk\n      samples.push({ firstChunk: 1, samplesPerChunk, sampleDescIndex: 1 })\n      if (remaining) {\n        samples.push({ firstChunk: len + 1, samplesPerChunk: remaining, sampleDescIndex: 1 })\n      }\n    }\n  }\n}\n","import * as flv from './flv'\nimport * as mpegTs from './mpeg-ts'\nimport * as mp4 from './mp4'\nimport * as model from './model'\nimport { Logger } from './utils'\n\nexport default {\n  ...flv,\n  ...mpegTs,\n  ...mp4,\n  ...model,\n  Logger\n}\n"],"names":["TrackType","VIDEO","AUDIO","METADATA","VideoCodecType","AVC","HEVC","AudioCodecType","AAC","G711PCMA","G711PCMU","WarningType","LARGE_AV_SHIFT","LARGE_VIDEO_GAP","LARGE_VIDEO_GAP_BETWEEN_CHUNK","LARGE_AUDIO_GAP","AUDIO_FILLED","AUDIO_DROPPED","VideoTrack","_classCallCheck","_defineProperty","this","undefined","_createClass","key","value","sequenceNumber","width","height","fpsDen","fpsNum","duration","baseMediaDecodeTime","timescale","codec","present","pid","pps","sps","vps","sarRatio","samples","warnings","hvcC","length","get","isVideoEncryption","AudioTrack","sampleDuration","sampleRate","channelCount","config","codecType","isAudioEncryption","VideoSample","pts","dts","units","originPts","originDts","keyframe","flag","dependsOn","isNonSyncSample","AudioSample","data","sampleOffset","size","byteLength","Sample","FlvScriptSample","_Sample","_inherits","_super","_createSuper","apply","arguments","SeiSample","_Sample2","_super2","MetadataTrack","flvScriptSamples","seiSamples","ExpGolomb","Error","_data","_bytesAvailable","_loadWord","_bitsAvailable","position","availableBytes","Math","min","workingBytes","Uint8Array","set","subarray","_word","DataView","buffer","getUint32","count","skipBytes","floor","bits","val","readBits","leadingZeroCount","skipLZ","skipBits","clz","readUEG","lastScale","nextScale","j","readEG","Logger","name","_prefix","concat","_console","disabled","_len","args","Array","_key","console","warn","UTF8","uint8array","out","input","i","push","String","fromCharCode","_checkContinuation","ucs4","_ucs2","join","start","checkLength","array","isBrowser","window","ua","navigator","userAgent","toLocaleLowerCase","isSafari","test","isFirefox","includes","isAndroid","concatUint8Array","arr","filter","Boolean","reduce","p","c","prevLen","forEach","d","MAX_SIZE","pow","readBig16","readBig32","readBig64","getAvcCodec","codecs","h","toString","formatIV","iv","Number","slice","toUpperCase","bufferToString","len","parse","a","isArray","parseInt","map","item","NALu","end","offset","dataLen","unit","isHevc","type","uuid","payload","uint","emulationPreventionBytesPositions","newLength","newData","sourceIndex","shift","nalUnitSize","spsParsed","spsSize","spsArr","ppsArr","spsCount","parseSPS","removeEPB","ppsSize","ppsCount","eg","readUByte","profileIdc","profileCompatibility","levelIdc","skipUEG","chromaFormat","chromaFormatIdc","readBool","scalingListCount","skipScalingList","picOrderCntType","numRefFramesInPicOrderCntCycle","picWidthInMbsMinus1","picHeightInMapUnitsMinus1","frameMbsOnlyFlag","fixedFrame","fps","frameCropLeftOffset","frameCropRightOffset","frameCropTopOffset","frameCropBottomOffset","aspectRatioIdc","numUnitsInTick","timeScale","ceil","rate","FREQ","indexOf","skip","frames","samplingFrequencyIndex","protectionSkipBytes","frameLength","objectType","_AAC$_getConfig","_getConfig","frameIndex","getFrameDuration","remaining","originCodec","_AAC$_getConfig2","samplingIndex","originObjectType","extensionSamplingIndex","vpsParsed","nalUnitType","numNalus","nalSize","vpsArr","numOfArrays","parseVPS","vpsMaxSubLayersMinus1","numTemporalLayers","max","_parseProfileTierLevel","spsMaxSubLayersMinus1","temporalIdNested","separateColourPlaneFlag","confWinLeftOffset","confWinRightOffset","confWinTopOffset","confWinBottomOffset","conformanceWindowFlag","bitDepthLumaMinus8","bitDepthChromaMinus8","subWidthC","subHeightC","maxSubLayersMinus1","generalTierFlag","generalProfileSpace","generalProfileIdc","generalProfileCompatibilityFlags","generalConstraintIndicatorFlags","generalLevelIdc","subLayerProfilePresentFlag","subLayerLevelPresentFlag","bitsAvailable","MAX_SILENT_FRAME_DURATION","AUDIO_EXCETION_LOG_EMIT_DURATION","FlvFixer","videoTrack","audioTrack","metadataTrack","_baseDts","_baseDtsInited","_audioNextPts","_videoNextDts","_audioTimestampBreak","_videoTimestampBreak","_lastVideoDuration","_keyFrameInNextChunk","_lastAudioExceptionGapDot","Infinity","_lastAudioExceptionOverlapDot","_lastAudioExceptionLargeGapDot","_lastVideoExceptionLargeGapDot","_lastVideoExceptionChunkFirstDtsDot","_this","startTime","discontinuity","contiguous","round","_videoLastSample","_calculateBaseDts","resetBaseDts","exist","_resetBaseDtsWhenStreamBreaked","_fixAudio","_fixVideo","s","time","_this2","refSampleDurationInt","x","first","last","lastSample","pop","unshift","samp0","firstSample","vDelta","abs","_samples$","nextDts","firstSampleDts","nextSampleDts","nextSample","refSampleDuration","_this3","_doFixAudioInternal","audioSamps","videoSamps","audioBasePts","videoBaseDts","baseDts","delta","isFinite","_getG711Duration","sampleDurationInSampleRate","nextPts","sample","silentFrame","_getSilentFrame","silentSample","splice","track","sampleSize","getSilentFrame","AMF","ret","_parseValue","byteOffset","view","isEnd","getUint8","getFloat64","_AMF$_parseString","_parseString","terminal","_AMF$_parseObject","_parseObject","_terminal","_AMF$_parseObject2","strictArrayLength","_AMF$_parseValue","timestamp","getInt16","Date","decode","getUint16","logger","FlvDemuxer","_fixer","_remainingData","_headerParsed","reset","probe","tagType","dataSize","bodyData","prevTagSize","_parseAudio","_parseVideo","_parseScript","formatTimescale","hasSample","fix","demux","format","soundRate","soundSize","soundType","AUDIO_RATE","_parseAac","_parseG711","parseAudioSpecificConfig","sampleRateIndex","frameType","codecId","packetType","cts","configData","parseHEVCDecoderConfigurationRecord","parseAVCDecoderConfigurationRecord","parseAvcC","_checkAddMetaNalToUnits","setToKeyframe","parseSEI","_gopId","gopId","hevc","_needAddMetaBeforeKeyFrameNal","MAX_VIDEO_FRAME_DURATION","TsFixer","vSamples","aSamples","firstVideoSample","firstAudioSample","vaDelta","vDeltaToNextDts","aDeltaToNextDts","_samples$i","prevDts","second","expectFragEnd","_audioLastSample","TsDemuxer","_pmtId","_remainingPacketData","_videoPesData","_audioPesData","remainingLength","videoPid","audioPid","payloadUnitStartIndicator","adaptationFiledControl","tableEnd","programInfoLength","esPid","_parseVideoData","_parseAudioData","pes","_parsePES","_toConsumableArray","parseAnnexB","_createVideoSample","spsInfo","_pushVideoSample","_parseAacData","_track$samples","parseADTS","headerDataLen","pesLen","ptsDtsFlags","MP4Parser","names","headerSize","subData","findBox","box","parseBox","trackId","baseDataOffsetPresent","flags","sampleDescriptionIndexPresent","defaultSampleDurationPresent","defaultSampleSizePresent","defaultSampleFlagsPresent","baseDataOffset","sampleDescriptionIndex","defaultSampleDuration","defaultSampleSize","defaultSampleFlags","reference_ID","version","earliest_presentation_time","first_offset","references","ref","tmp32","reference_type","referenced_size","subsegment_duration","starts_with_SAP","SAP_type","SAP_delta_time","mvhd","trak","pssh","nextTrackId","tkhd","mdia","mdhd","hdlr","minf","lang","language","handlerType","vmhd","smhd","stbl","graphicsmode","opcolor","balance","_ret$stsd$entries$","_ret$stsd$entries$$si","_ret$stsd$entries$$si2","stsd","stts","ctts","stsc","stsz","stco","co64","default_IV_size","entries","sinf","schi","tenc","stss","senc","sampleCount","InitializationVector","subsamples","subsampleCount","subsample","BytesOfClearData","BytesOfProtectedData","keyIds","systemId","toHex","numKeyIds","keyId","data_size","kid","system_id","entryCount","b","avc1","hvc1","mp4a","alaw","samplesize","esds","horizresolution","vertresolution","avcC","pasp","default_IsEncrypted","default_KID","frma","data_format","bodyStart","parseVisualSampleEntry","configurationVersion","AVCProfileIndication","AVCLevelIndication","lengthSizeMinusOne","spsLength","ppsLength","tmp","generalProfileCompatibility","avgFrameRate","_ret$vps","nalus","_ret$sps","_ret$pps","hSpacing","vSpacing","parseAudioSampleEntry","byteRead","tag","substring","padStart","firstChunk","samplesPerChunk","entrySizes","mfhd","traf","t","tfhd","tfdt","trun","dataOffset","firstSampleFlags","isLeading","isDependedOn","hasRedundancy","paddingValue","degradationPriority","moov","_e$esds","_e$esds2","tracks","vTrack","find","_t$mdia","_t$mdia$hdlr","aTrack","_t$mdia2","_t$mdia2$hdlr","_vTrack$tkhd","_vTrack$mdia","_vTrack$mdia$minf","_vTrack$mdia$minf$stb","_vTrack$mdia2","_vTrack$mdia2$minf","_vTrack$mdia2$minf$st","v","_vTrackId","id","tkhdDuration","mvhdDurtion","mvhdTimecale","_e1$sinf","_e1$sinf$schi","_e1$sinf2","_e1$sinf2$schi","_e1$sinf3","_e1$sinf3$schi","_e1$sinf4","_e1$sinf4$frma","e1","ext","videoSenc","useEME","kidValue","encv","_aTrack$tkhd","_e$esds3","_e$esds4","_aTrack$mdia","_aTrack$mdia$minf","_aTrack$mdia$minf$stb","_aTrack$mdia2","_aTrack$mdia2$minf","_aTrack$mdia2$minf$st","_aTrackId","_e$sinf","_e$sinf$frma","_e$sinf2","_e$sinf2$schi","_e$sinf3","_e$sinf3$schi","_e$sinf4","_e$sinf4$schi","getRateIndexByRate","from","audioSenc","enca","_videoTrack$encv","_audioTrack$enca","vkid","akid","videoSampleCount","_audioTrack$samples","audioSampleCount","moof","_ref","defaultSize","defaultDuration","evaluateDefaultDuration","index","_t$mdia3","_t$mdia3$hdlr","_t$mdia4","_t$mdia4$hdlr","videoSamples","audioSamples","_vTrack$mdia3","_vTrack$mdia3$minf","videoStbl","getSamples","_aTrack$mdia3","_aTrack$mdia3$minf","_aTrack$mdia$mdhd","audioStbl","keyframeMap","cttsArr","cttsEntries","stscEntries","stcoEntries","stszEntrySizes","stssEntries","_ref2","pos","chunkIndex","chunkRunIndex","offsetInChunk","lastSampleInChunk","lastChunkInRun","_ref3","dataReferenceIndex","frameCount","depth","isFullBox","readBig24","str","pad","charstr","maxlen","chars","r","hex","FMP4Demuxer","videoData","audioData","videoExist","audioExist","moovBox","moovToTrack","moofBox","moofToSamples","baseOffset","sampleData","videoBaseMediaDecodeTime","audioBaseMediaDecodeTime","Object","keys","k","Concat","ResultConstructor","totalLength","arrays","result","Buffer","self","_len2","_key2","UINT32_MAX","MP4","FTYPHEV1","FTYPAVC1","init","ftyp","content","types","mvex","HDLR_TYPES","VMHD","SMHD","DINF","extBox","STTS","STSC","STSZ","STCO","avc1hev1","_concat$concat","avcc","btrt","charCodeAt","schm","typ","boxes","fiel","_concat$concat2","ArrayBuffer","pcf","cif","write","_ref4","_slicedToArray","trex","sencLength","isVideo","videoSencLength","saiz","saio","trun1","sbgp","sdtp","extension","writeUint32","samplesLength","writeUint16","upperWordBaseMediaDecodeTime","lowerWordBaseMediaDecodeTime","sampleLen","_samples$i$flag","_samples$i$cts","trackMP4","mdiaMP4","minfMP4","stblMP4","_ref5","_ref6","sampleDescIndex","samplesSizes","offsets","keyframeIndexes","_ref7","styp","durationCount","earliestTime","mdatSize","sidx","mdat","create","video","audio","dinf","dref","StblTable","enable","debug","_console2","log","_console3","_len3","_key3","_console4","_len4","_key4","error","_console5","group","table","groupEnd","FMP4Remuxer","options","browserVersions","exec","forceFirstIDR","openLog","createInit","videoInitSegment","audioInitSegment","initSegment","videoSegment","audioSegment","hasVideo","hasAudio","initMerge","_remuxVideo","_remuxAudio","mdata","mdatView","_loop","_offset","_sample","u","setUint32","l","Base","properties","assign","clone","constructor","_construct","WordArray","_Base","words","sigBytes","call","typedArray","Int8Array","Uint8ClampedArray","Int16Array","Uint16Array","Int32Array","Uint32Array","Float32Array","Float64Array","typedArrayByteLength","_words","encoder","Hex","stringify","wordArray","thisWords","thatWords","thisSigBytes","thatSigBytes","clamp","thatByte","_get","_getPrototypeOf","prototype","nBytes","rcache","m_w","_m_w","_m_z","mask","random","_r","hexChars","bite","hexStr","hexStrLength","substr","Latin1","latin1Str","latin1StrLength","Utf8","utf8Str","unescape","encodeURIComponent","BufferedBlockAlgorithm","_Base2","_minBufferSize","_nDataBytes","m_data","doFlush","processedWords","blockSize","dataWords","dataSigBytes","nBlocksReady","nWordsReady","nBytesReady","_doProcessBlock","Hasher","_BufferedBlockAlgorit","_super3","cfg","_doReset","messageUpdate","_append","_process","hash","_doFinalize","SubHasher","message","finalize","HMAC","_Base3","_super4","_this4","hasher","_hasher","hasherBlockSize","hasherBlockSizeBytes","oKey","_oKey","iKey","_iKey","oKeyWords","iKeyWords","update","innerHash","hmac","Base64","_map","base64Chars","triplet","charAt","paddingChar","base64Str","base64StrLength","reverseMap","_reverseMap","paddingIndex","parseLoop","bits1","bitsCombined","T","sin","FF","n","GG","HH","II","MD5Algo","_Hasher","_hash","M","_M","offset_i","M_offset_i","H","M_offset_0","M_offset_1","M_offset_2","M_offset_3","M_offset_4","M_offset_5","M_offset_6","M_offset_7","M_offset_8","M_offset_9","M_offset_10","M_offset_11","M_offset_12","M_offset_13","M_offset_14","M_offset_15","nBitsTotal","nBitsLeft","nBitsTotalH","nBitsTotalL","H_i","_createHelper","_createHmacHelper","EvpKDFAlgo","keySize","iterations","password","salt","derivedKeyWords","block","derivedKey","Cipher","xformMode","_xformMode","dataUpdate","finalProcessedData","_ENC_XFORM_MODE","_DEC_XFORM_MODE","SubCipher","selectCipherStrategy","PasswordBasedCipher","SerializableCipher","encrypt","decrypt","ciphertext","ivSize","BlockCipherMode","cipher","_cipher","_iv","Encryptor","Decryptor","xorBlock","_prevBlock","CBC","_BlockCipherMode","_CBC","_class","_super5","encryptBlock","_CBC2","_class2","_super6","thisBlock","decryptBlock","Pkcs7","blockSizeBytes","nPaddingBytes","paddingWord","paddingWords","padding","unpad","BlockCipher","_Cipher2","_super7","mode","modeCreator","createEncryptor","createDecryptor","_mode","__creator","processBlock","finalProcessedBlocks","CipherParams","_super8","cipherParams","_this5","mixIn","formatter","OpenSSLFormatter","openSSLStr","ciphertextWords","_super9","_cfg","encryptor","cipherCfg","algorithm","_ciphertext","plaintext","_parse","OpenSSLKdf","execute","_salt","compute","_SerializableCipher","_super10","derivedParams","kdf","_SBOX","INV_SBOX","_SUB_MIX_0","_SUB_MIX_1","_SUB_MIX_2","_SUB_MIX_3","INV_SUB_MIX_0","INV_SUB_MIX_1","INV_SUB_MIX_2","INV_SUB_MIX_3","xi","sx","x2","x4","x8","RCON","AESAlgo","_BlockCipher","_nRounds","_keyPriorReset","keyWords","ksRows","_keySchedule","keySchedule","ksRow","_invKeySchedule","invKeySchedule","invKsRow","_doCryptBlock","SUB_MIX_0","SUB_MIX_1","SUB_MIX_2","SUB_MIX_3","SBOX","nRounds","s0","s1","s2","s3","t0","t1","t2","t3","AES","CTR","_CTR","counter","_counter","keystream","NoPadding","Crypto","decryptWordArray","raw","realKey","realIV","decryptWord","wordArrayToUint8Array","w","decoderAESCTRData","customDescryptHandler","sencBox","encodeWord","encodeBuffers","decodeBuffers","tempBuffer","decrypted","clearDataBuf","protectedDataLen","decodeProtectedData","dec","MP4Demuxer","videoSegmnents","audioSegmnents","_this$_videoSamples","_videoSamples","_this$_audioSamples","_audioSamples","moovToSamples","dataStart","videoIndexRange","audioIndexRange","parseSamples","startByte","frame","_lastRemainBuffer","_lastRemainBufferStartPos","tryCnt","temp","e","errorMessage","videoEndByte","audioEndByte","startPts","endPts","decoderData","MP4Remuxer","_remuxMix","_remuxTrack","_this$_remuxData","_remuxData","mdatData","chunkOffset","moovMP4","totalDuration","_fillCttsSamples","_fillSttsSamples","_fillStcoSamples","_fillStscSamples","sttsSamples","cur","next","cttsSamples","stcoSamples","samplePerChunk","_objectSpread","flv","mpegTs","mp4","model"],"mappings":"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"}